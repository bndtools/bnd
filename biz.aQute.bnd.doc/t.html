<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>${title}</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="css/normalize.css">
        <link rel="stylesheet" href="css/main.css">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

		<article>
		<section>
	<p>FRONT MATTER</p>

</section><section>
	<h1><span class=bndoc-counter>1</span>Background</h1>
<p>bnd is the Swiss army knife of OSGi, it is used for creating and working with OSGi bundles. Its primary goal is take the pain out of developing bundles. With OSGi you are forced to provide additional metadata in the JAR's manifest to verify the consistency of your "class path". This metadata must be closely aligned with the class files in the bundle and the policies that a company has about versioning. Maintaining this metdata is an error prone chore because many aspects are redundant.</p>
<p>bnd's raison d'etre is therefore to remove the chores and use the redundancy to create the manifest from the class files instead of maintaining it by hand. The core task is therefore to analyze the class files and find any dependencies. These dependencies are then merged with ''instructions'' supplied by the user. For example, adding a version to all imported packages from a specific library can be specified as:</p>
<pre>Import-Package: com.library.*; version = 1.21
</pre>
<p>The OSGi manifest must explicitly mention a package, bnd allows the use of wildcards. bnd contains many more such conveniences. bnd roots are about 10 years old and bnd has therefore a large number of functions that remove such chores. These range from simplifying the use of OSGi Declarative Services, working with Spring and Blueprint, WAR and WAB files, version analysis, project dependencies, and much more.</p>
<p>Over time bnd started to appear in many different incarnations. It is an an ant task, a command line utility, and a bundle for Eclipse. Other projects have used bndlib to create a maven plugin, bndtools and Sigil both Eclipse IDEs, and others. By keeping the core library small and uncoupled (bnd has no external connections except Java 5), it is easy to embed the functionality in other projects.</p>
<h2><span class=bndoc-counter>1.1</span>Workflow</h2>
<p>Traditionally, JAR files were made with the JDK jar tool, the jar ant task, or the Maven packager. All these tools share the same concept. The developer creates a directory image of the jar by copying files to a directory; this directory is then jarred. This model can be called the ''push'' model. Obviously this method works well.</p>
<p>bnd works differently, it uses the ''pull'' model. Instructions in the bnd file describe the contents of the desired JAR file without writing this structure to disk. The contents from the output can come from the class path or from anywhere in the file system. For example, the following instruction includes the designated packages in the JAR:</p>
<p>Private-Package: com.example.*</p>
<p>bnd can create a JAR from packages the sources, directories or other JAR files. You never have to copy files around, the instructions that Bnd receives are sufficient to retrieve the files from their original location, preprocessing or filtering when required.</p>
<p>The Jar is constructed from 3 different arguments:</p>
<pre>Export-Package
Private-Package
Include-Resource
</pre>
<p>Private-Package and Export-Package contain ''instructions''. Instructions are patterns + attributes and directives, looking like normal OSGi attributes and directives. For example:</p>
<pre>Export-Package: com.acme.*;version=1.2
</pre>
<p>Each instruction is applied to each package on the classpath in the definition order. That is, if an earlier instruction matches, the later instruction never gets a chance to do its work. If an instruction matches its attributes and properties are applied to the packages. The difference between the Private-Package argument and the Export-Package arguments is that the export version selects the packages for export. If the packages overlap between the two, the export wins.</p>
<p>An instruction can also be negative when it starts with a '!'. In that case the package is excluded from the selection. For example:</p>
<pre>Export-Package: !com.acme.impl, com.acme.*;version=1.2
</pre>
<p>Note that the instructions are applied in order. If the ! instruction was at the end in the previous example, it would not have done its work because the com.acme.* would already have matched.</p>
<p>The Include-Resource argument can be used to copy resources from the file system in the JAR. This is useful for licenses, images, etc. The instructions in the argument can be a directory, a file, or an inline JAR. The default JAR path is the the root for a directory or the filename for a file. The path can be overridden. Instructions that are enclosed in curly braces, like {license.txt}, are pre-processed, expanding any macros in the file.</p>
<p>Once the JAR is created, the bnd program analyzes the classes and creates an import list with all the packages that are not contained in the jar but which are referred to. This import list is matched against the Import-Package instructions. Normally, the Import-Package argument is *; all referred packages will be imported. However, sometimes it is necessary to ignore an import or provide attributes on the import statement. For example, make the import optional or discard the import:</p>
<pre>Import-Package: !com.acme.*, *;resolution:=optional
</pre>
<p>The arguments to bnd are normal given as a set of properties. Properties that begin with an upper case are copied to the manifest (possibly after processing). Lower case properties are used for macro variables but are not set as headers in the manifest.</p>
<p>After the JAR is created, the bnd program will verify the result. This will check the resulting manifest in painstaking detail.</p>
<p>The bnd program works on a higher level then traditional jarring; this might take some getting used to. However, it is much more elegant to think in packages than that it is to think in files. The fact that bnd understand the semantics of a bundle allows it to detect many errors and allows bundles to be created with almost no special information.</p>
<p>bnd will not create an output file if none of the resources is newer than an existing output file.</p>
<p>The program is available in several forms: command line, ant task, maven plugin, and an Eclipse plugin.</p>
<h2><span class=bndoc-counter>1.2</span>Tips</h2>
<p>There are some common pitfalls that can be prevented by following the tips:</p>
<ul>
<li>Keep it simple. bnd's defaults are pretty good and not specifying is usually the best solution. KISS!</li>
<li>Think packages ... yes it feels redundant to specify the packages that are in your source directory but your artifact will get a life of its own over time. Many IDEs and build tools restricted us to one artifact per project but bnd allows many artifacts, allowing the choice of granularity to you. As OSGi's packages can be easily refactored you can design the contents of your artifacts depending on the deployment needs. Think packages!</li>
<li>Private is always better than export, only use export when you absolute need it.</li>
<li>Not versioning an exported package is at your own peril. Sorry, that is false, it is at the peril of your users.</li>
<li>Do not use the Bundle-ClassPath, if you need to include whole JARs, see the @ option at Include-Resource</li>
<li>If you do not understand a header, remove it</li>
<li>If you have a problem, make an example that is as small as possible and send it to [me][mailto:Peter.Kriens@aQute.biz|me].</li>
</ul>

</section><section>
	<h1><span class=bndoc-counter>2</span>Download</h1>
<p>TODO download/install instructions</p>
<h2><span class=bndoc-counter>2.1</span>Where bnd is Used</h2>
<p>bnd is already used by several different projects.</p>
<ul>
<li><a href="http://felix.apache.org/site/apache-felix-maven-bundle-plugin-bnd.html">Maven Bundle Plugin</a></li>
<li><a href="http://www.gradleware.com/">Gradle</a></li>
<li><a href="http://bndtools.org">bndtools</a></li>
</ul>
<p>TODO update list of projects that use bnd</p>
<p>If you're a developer of a tool that needs to be listed here, do not hesitate to ask Peter.Kriens@aQute.biz.</p>
<h2><span class=bndoc-counter>2.2</span>Source Code</h2>
<p>bnd is maintained at <a href="https://github.com/bndtools/bnd">github</a></p>
<h2><span class=bndoc-counter>2.3</span>Maven Central</h2>
<p>Maven Central may lag in its version but can be used with:</p>
<pre>&lt;dependency&gt;
  &lt;groupId&gt;biz.aQute&lt;/groupId&gt;
  &lt;artifactId&gt;bndlib&lt;/artifactId&gt;
  &lt;version&gt;2.2.0&lt;/version&gt;
&lt;/dependency&gt;
</pre>
<h2><span class=bndoc-counter>2.4</span>Download Latest Version</h2>
<ul>
<li><a href="http://www.gradleware.com/">Master build</a></li>
</ul>

</section><section>
	<h1><span class=bndoc-counter>3</span>Quick Start</h1>
<p>Assume we need to create a bundle in Eclipse. Each Java project in Eclipse has a set of sources and a class path. bnd therefore knows, about all the classes. However, it does not know how you want to structure your JARs/Bundles. It therefore needs a description file, the ''bnd file''. If you create such a file, you should give it the same as name as the bundle symbolic name with a <code>.bnd</code> extension. For example <code>aQute.example.bnd</code> is a well chosen name. If the name is not <code>bnd.bnd</code>, the file name without the .bnd extension is the default for your bundle symbolic name.</p>
<p>Lets build a bundle for the aQute OSGi tutorial Chat example. This bundle has 2 packages.</p>
<ul>
<li>aQute.service.channel</li>
<li>aQute.tutorial.chat</li>
</ul>
<p>The <code>aQute.service.channel</code> package must be exported and the other package may remain private. All packages that are referred from the source code must be imported. To achieve this, the following manifest will suffice:</p>
<pre>Export-Package: aQute.service.channel; version=1.0 
Private-Package: aQute.tutorial.chat
</pre>
<p>This is all you need! In Eclipse, you can select the bnd file and run the <code>Make Bundle</code> command. This will create a JAR with the proper content:</p>
<pre>META-INF 
  MANIFEST.MF 
aQute/service/channel 
  Channel.class 
  aQute/tutorial/chat 
  Chat$ChannelTracker.class 
  Chat.class
</pre>
<p>You can run the same command from the command line</p>
<pre>$ bnd aQute.tutorial.chat.bnd
</pre>
<p>Now take a look at the JAR file's manifest. With the command line version of you can do this with <code>bnd aQute.tutorial.chat.jar</code>. Otherwise just open the JAR with WinZip.</p>
<p>Manifest-Version: 1
Bundle-Name: aQute.tutorial.chat
Private-Package: aQute.tutorial.chat
Import-Package: aQute.service.channel;version=1.0,
org.osgi.framework; version=1.3,
org.osgi.util.tracker;version=1.3
Bundle-ManifestVersion: 2
Bundle-SymbolicName: aQute.tutorial.chat
Export-Package: aQute.service.channel;version=1.0
Bundle-Version: 0</p>
<p>As you can see, bnd filled in a number of headers. The first header, Manifest-Version is required by the JAR standard. Bundle-Name is derived from the Bundle-SymbolicName because we did not specify it. The Private-Package header specifies the packages that ended up not exported. The Import-Package header comes from the packages that were referred to from the contained packages (private and exported). As you can see, bnd picked up versions for the imported packages. These versions come from the manifest of the JARs that source these packages, or from the packageinfo file. The Export-Package shows the export of the service package. On top of this, bnd has verified that all your headers really match the OSGi specifications, or you will get errors and warnings.</p>

</section><section>
	<h1><span class=bndoc-counter>4</span>Overview</h1>

</section><section>
	<h1><span class=bndoc-counter>5</span>Projects</h1>
<h2><span class=bndoc-counter>5.1</span>Project Properties</h2>
<p>There are a number of built in properties that are set by bnd:</p>
<p>||!Property name ||!Description ||
||<code>project</code>||Name of the project. This is the name of the bnd file without the .bnd extension. If this name is bnd.bnd, then the directory name is used. ||
||<code>project.file</code>||Absolute path of the main bnd file. ||
||<code>project.name</code>||Just the name part of the file path ||
||<code>project.dir</code>||The absolute path of the directory in which the bnd file resides. ||</p>
<h2><span class=bndoc-counter>5.2</span>Run instructions</h2>
<p>Run instructions are used to start OSGi tests and OSGi runs.</p>
<p><table>
<td>Instructions</td>
<td>Argument</td>
<td>Description</td></p>
<p>(:cellnr:)<code>-runbundles</code>
<td><code>LIST SPEC</code></td>
<td>Additional bundles that will be installed and started when the framework is launched. This property is normally part of the project's <code>bnd.bnd</code> file.</td></p>
<p>(:cellnr:)<code>-runvm</code>
<td><code>PROPERTIES</code></td>
<td>Properties given to the VM before launching. This property is normally set in the cnf/build.bnd file and only in rare cases overridden in the bnd.bnd file.</td></p>
<p>(:cellnr:)<code>-runproperties</code>
<td><code>PROPERTIES</code></td>
<td>Properties given to the framework when launching. Usually project specific.</td></p>
<p>(:cellnr:)<code>-runsystempackages</code>
<td><code>PACKAGES</code></td>
<td>A declaration like Import-Package that specifies additional system packages to import from the class path. Usually given in the cnf/build.bnd file.</td></p>
<p>(:cellnr:)<code>-runpath</code>
<td><code>LIST SPEC</code></td>
<td>A path description of artifacts that must be on the classpath of the to be launched framework.  Usually given in the cnf/build.bnd file. This path should contain the framework. Any packages that a bundle on the -runpath should specify should be listed in the <code>export</code> attribute.</td></p>
<p>(:cellnr:)<code>-runtrace</code>
<td><code>true|'''false'''</code></td>
<td>Trace the startup of the framework to the console. Usually used during testing and development so project specific.</td></p>
<p>(:cellnr:)<code>-runframework</code>
<td><code>none|'''services'''</code></td>
<td><code>NONE</code> indicates that a mini built in framework should be used. <code>SERVICES</code> indicates that the <code>META-INF/services</code> model must be followed for the <code>org.osgi.framework.launch.FrameworkFactory</code> class. Project specific.</td></p>
<p>(:cellnr:)<code>-testpath</code>
<td><code>LIST SPEC</code></td>
<td>A path used to specify the test plugin</td></p>
<p>(:tableend:)</p>
<h2><span class=bndoc-counter>5.3</span>Launching</h2>
<p>Launching is needed when the project's <code>run</code> action or <code>test</code> action is executed. The project creates a Project Launcher. A Project Launcher must launch a new VM and set up this VM correctly. The VM is launched with the following information.</p>
<ul>
<li><code>java</code> - The command to launch a new VM is bu default <code>java</code>. However, this can be overridden by setting a property called <code>java</code>.</li>
<li><code>classpath</code> - The classpath set for the VM is derived from the <code>-runpath</code> property. Notice that this is supposed to contain the JAR with the framework. The <code>-runpath</code> requires bundle symbolic names for the JAR and an optional version range. bnd will use the latest version in the repository. Any packages that should be exported by the system bundle should have an export attribute containing the exported packages, like `junit.osgi;version=3.8;export="junit.framework;version=3.8,junit.misc;version=3.8".</li>
<li><code>vm options</code> - These options can be set in the <code>-runvm</code> property. They are usually in the form of <code>-Dxya=15</code> or <code>-X:agent=bla</code>. Options should be separated by commas.</li>
<li><code>main</code> - The class implementing the main type is defined by the launcher plugin.</li>
</ul>
<p>And example of a launcher set is:</p>
<p>-runvm:   -Xmn100M, -Xms500M, -Xmx500M
-runpath: \
org.apache.felix.framework; version=3.0, <br />
junit.osgi;export="junit.framework;version=3.8"
-runtrace: true
-runproperties: launch=42, trace.xyz=true
-runbundles: org.apache.felix.configadmin,<br />
org.apache.felix.log,<br />
org.apache.felix.scr,<br />
org.apache.felix.http.jetty,<br />
org.apache.felix.metatype,<br />
org.apache.felix.webconsole</p>
<p>Debugging launching is greatly simplified with the -runtrace property set to true. This provides a lot of feedback what the launcher is doing.</p>
<h3>>Access to arguments</h3>
<p>When the launcher is ready it will register itself as a service with the following properties:</p>
<p>||<code>launcher.arguments</code>||The command line arguments||
||<code>launcher.ready</code>||Indicating the launcher is read||</p>
<h3>>Access to main thread</h3>
<p>In certain cases it is necessary to grab the main thread after launching. The default launcher will launch all the bundles and then wait for any of those bundles to register a Runnable service with a service property <code>main.thread=true</code>. If such  service is registered, the launcher will call the run method and exit when this method returns.</p>
<h3>>Timeout</h3>
<p>The launcher will timeout after an hour. There is currently no way to override this timeout.</p>
<h3>>Mini Framework</h3>
<p>The bnd launcher contains a mini framework that implements the bare bones of an OSGi framework. The purpose of this mini framework is to allow tests and runs that want to launch their own framework. A launch that wants to take advantage of this can launch with the following property:</p>
<p>-runframework: none</p>
<h3>>Ant</h3>
<p>In ant, the following task provides the run facility.</p>
<p><target name="run" depends="compile">
<bnd command="run" exceptions="true" basedir=".name:          "  />
</target></p>
<p>These targets provide commands for <code>ant run</code>.</p>
<h2><span class=bndoc-counter>5.4</span>Testing</h2>
<p>Testing is in principle the same as launching, it actually uses the launcher. Testing commences with the <code>test</code> action in the project. This creates a Project Tester. bnd carries a default Project Tester but this can be overridden.</p>
<p>The basic model of the default Project Tester plugin is to look for bundles that have a <code>Test-Cases</code> manifest header after launching. The value of this header is a comma separated list of JUnit test case class names. For example:</p>
<p>Test-Cases: test.LaunchTest, test.OtherTest</p>
<p>Maintaining this list can be cumbersome and for that reason the <code>${classes}</code> macro can be used to calculate its contents:</p>
<pre>Test-Cases : ${classes;extending;junit.framework.TestCase;concrete}
</pre>
<p>See [classes macro][Macros#classes] for more information.</p>
<h3>>Ant</h3>
<p><target name="test" depends="compile">
<bnd command="test" exceptions="true" basedir=".name:          "  />
</target></p>
<h2><span class=bndoc-counter>5.5</span>Overriding the plugins</h2>
<p>Both the Project launcher and Project Tester are plugins. Defaults are provided by bnd itself (bnd carries a mini cache repo that is expanded in the cnf director), it is possible to add new launchers and testers as needed.</p>
<p>Plugins are found on the -runpath or the -testpath properties respectively. bnd will look for an appropriate manifest header. The header has a class name as value. It will then instantiate the class and use as launcher/tester. The classes must extend an abstract base class. Each plugin has access to the Project object, containing all the details of the project.</p>
<p>||Plugin             ||Manifest header||Base Class||Where||
||Project Launcher   ||Launcher-Plugin||ProjectLauncher||-runpath||
||Project Test       ||Tester-Plugin||ProjectLauncher||-testpath||</p>
<p>The plugin gets complete control and can implement many different strategies.</p>

</section><section>
	<h1><span class=bndoc-counter>6</span>Building Jars</h1>

</section><section>
	<h1><span class=bndoc-counter>7</span>Versioning</h1>
<p>Requires 1.15</p>
<p>Versioning is probably the most painful part of developing real software. Where toys and prototypes can be developed ignoring evolution, real software requires a migration path to an unknown future.</p>
<p>The OSGi has defined a versioning policy that is described in the [Semantic Versioning whitepaper][http://www.osgi.org/wiki/uploads/Links/SemanticVersioning.pdf]. bnd fully supports this model and provides many shortcuts. The goal of bnd is remove any manual work from versioning bundles as well as packages.</p>
<p>The key concept to version in OSGi is the ''package''. Bundles are an ''aggregate'' and therefore must move as fast as the fastest moving exported packages they contain. For example, if a bundle contains two exported packages <code>foo</code> and <code>bar</code> and <code>foo</code> is not changed but <code>bar</code> has a major change, then the bundle version needs to also have a major change. This requires an unnecessary update for a bundle that only depended on <code>foo</code>. Aggregating dependencies increases the fan out of the transitive dependencies. The result is that systems can only evolve when everything is updated simultaneously. The result is that the system as a whole becomes brittle.</p>
<p>In contrast, versioning the packages and using Import-Package, bundles can be refactored and versioned independently.</p>
<h2><span class=bndoc-counter>7.1</span>Best Practices</h2>
<ul>
<li>Version on packages, not on bundles</li>
<li>Create a packageinfo file with "version 1.0" in each package directory and maintain it meticuously for each change to the package. Any change that breaks consumers, increment major. Changes that break providers (if any), increment minor. Other changes micro. bnd will then properly version this package when exported</li>
<li>If you provide an API (as defined in te Semantic Versioning whitepaper) export the API package even if it is not in your project and put the <code>provide:=true</code> directive on the package export, e.g. <code>Export-Package: org.osgi.service.event; provide:=true</code>.</li>
<li>Every time when you release a bundle to the external world, bump the minor part of the bundle  version. For internal development releases, bump the micro part of the bundle version.</li>
</ul>
<h2><span class=bndoc-counter>7.2</span>Versions in OSGi</h2>
<p>A version in OSGi has 4 parts:</p>
<p>major        1
minor        1.1
micro        1.1.1
qualifier    1.1.1.qualifier</p>
<p>To survive versioning, one must have a ''version policy''. A version policy puts semantics on the version numbers. The ''recommended'' policy in OSGi is changing the part when there is:</p>
<p>major        a breaking change
minor        a backward compatible changes
micro        a bug fix (no API change)
qualifier    a new build</p>
<p>In OSGi, the decision was taken to have a single export version. The import statement allows a version range to be set. For example:</p>
<p>Export-Package: com.acme.foo; version=1.0.2
Import-Package: com.acme.bar; version="[1,2)"</p>
<p>The semantic versioning white paper introduces two terms that are orthogonal to the imports and exports as well as implementing or delegating:</p>
<ul>
<li>Provide an API - Provide the functionality defined in an API</li>
<li>Consume an API - Consume the functionality defined in an API</li>
</ul>
<p>Provide and consume is orthogonal to implementing an interface and delegating. For example, the Configuration Admin service has the <code>ConfigurationAdmin</code> interface that is implemented by the Provider of an API but the <code>ConfigurationListener</code> interface is implemented by the Consumer of the API.</p>
<p>The reason for the providers and consumer terms is that version policies are different. A change in an API almost always affects the provider but with careful API design it is often possible to make a change backward compatible for consumers.</p>
<h2><span class=bndoc-counter>7.3</span>Versioning Packages</h2>
<p>If you have a package that is containing implementation code that is supposed to be directly used by the consumers then this is a ''library''.
A library package is not an API that can be implemented by other bundles, it is the implementation. Then the versioning of library packages is relatively straightforward: Any change that breaks a consumer of that package must increment the major version number. For example, if the popular ASM library would add a method to the <code>MethodVisitor</code> class then it must increment the major version number of the <code>org.objectweb.asm</code> package because all existing consumers of this library would then be broken.</p>
<p>If however a package contains an API that is provided and consumed by others the situation is more complex. In such a case, the provider should export the API package and the consumers should import it.</p>
<p>bnd explicitly allows the inclusion of packages that come from other projects. It is just good practice to include an API package in your bundle if you are the provider of that API. However, this means that maintaining the version of the package in the manifest is ''wrong'', it would have to be maintained in several places, which is very error prone.</p>
<p>For this reason, bnd provides a way to store the version of the package together with the package itself. One with annotations and one without when annotations are not possible.</p>
<p>The @Version annotation is placed on the package. Since Java 5 it is possible to create a package-info.java file that can be used to annotate packages:</p>
<p>package-info.java:
@Version("1.2.0.${workspace}/cnf")
package com.example;</p>
<pre>import aQute.bnd.annotation.Version;
</pre>
<p>A non-annotation based alternative is the <code>packageinfo</code> file. When bnd scans the Java archives it will look in each package for this packageinfo file. The format of this file is very simple:</p>
<p>packageinfo:
version 1.2.0.v${workspace}/cnf</p>
<p>In either case, the value for the version may contain macros.</p>
<p>If you now export the package (from any bundle that has the package on its class path), it will be properly versioned.</p>
<p>bnd.bnd:
build = 201312131817
Export-Package: com.example.*</p>
<p>The resulting manifest will look like:</p>
<p>Manifest:
Export-Package: com.example; version=1.2.0.v201010101010</p>
<p>If you export a a package from another bundle, bnd will also look in the manifest of that other bundle for a version.</p>
<p>Using packageinfo (or the @Version annotation) is highly recommended.</p>
<h2><span class=bndoc-counter>7.4</span>Import Version Policy</h2>
<p>If you import a package bnd will look at the exported version of that package. This version is not directly suitable for the import because it is usually too specific, it needs a policy to convert this export version to an import version.</p>
<p>An importer that provides the functionality of an API package is much closer tied to that package than a client. The whitepaper recommends binding to the major.minor part of the version for a provider. That is, any change in the minor part of the version breaks the compatibility. This makes sense, the provider of an API must implement the contract and is therefore not backward compatible for any change in the API. A consumer of the API only has to be bound to the major part because it is much more relaxed for the backward compatibility.</p>
<p>For example, a new method is added to an interface that is implemented by the provider of the API. Old clients have no visibility of this method because when they compiled it did not exist. However, the provider of the API must be modified to implement this method otherwise more modern clients would break.</p>
<p>This asymmetry creates the need for two version policies:</p>
<p>-provider-policy :    ${range;[==,=+)}
-consumer-policy :    ${range;[==,+)}</p>
<p>The given values are the defaults. The value of the version policy will be used calculate the import based on the exported package. The [${range}][Macros#range] macro provides a convenient shortcut to do this using a version mask.</p>
<p>For example, a bundle that implements the OSGi Event Admin service can use the following bnd file:</p>
<p>bnd.bnd:
Private-Package: com.example.impl.event</p>
<p>The resulting manifest would look like:</p>
<p>Manifest:
Import-Package:  org.osgi.service.event; version="[1.1,2)", ...
...</p>
<p>How does bnd know if a bundle is a provider or a consumer of a specific package? Well, the default is the consumer policy but this can be overridden with the <code>provide:=true</code> directive that works on the <code>Import-Package</code> clauses as well as on the <code>Export-Package</code> clauses.</p>
<p>The <code>provide:</code> directive indicates to bnd that the given package contains API that is provided by this bundle. The (strongly) recommended way is to put the <code>provide:=true</code> directive on the <code>Export-Package</code> header, even if the package comes from another bundle. This way the bundle contains a copy of the package that is by default imported with the proper provider policy range.</p>
<p>For example, an implementation of the OSGi Event Admin specification could use the following bnd file:</p>
<p>bnd.bnd:
Export-Package:  org.osgi.service.event; provide:=true
Private-Package: com.example.impl.event</p>
<p>The resulting manifest would look like:</p>
<p>Manifest:
Export-Package:  org.osgi.service.event; version=1.1
Import-Package:  org.osgi.service.event; version="[1.1,1.2)", ...
...</p>
<p>If for some reason it is not desirable to export the API package in the implementation bundle, then the <code>provide:</code> directive can also be applied on the <code>Import-Package</code> header:</p>
<p>bnd.bnd
Import-Package: org.osgi.service.event; provide:=true, *
Private-Package: com.example.impl.event</p>
<p>The resulting manifest would look like:</p>
<p>Manifest:
Import-Package:  org.osgi.service.event; version="[1.1,1.2)", ...
...</p>
<h2><span class=bndoc-counter>7.5</span>Substitution</h2>
<p>A key aspect of OSGi is that a package can be both imported and exported. The reason is that this feature allows a framework more leeway during resolving without creating multiple unconnected class spaces.</p>
<p>After the bundle has been created and analyzed bnd will see if an exported package is eligible for import. An export is automatically imported when the following are true:</p>
<ul>
<li>There exists at least one reference to the exported package from a private package</li>
<li>The exported package has no references to any private packages</li>
<li>The exported package does not have a <code>-noimport:</code> directive.</li>
</ul>
<p>If a package is imported it will use the version as defined by the version policy.</p>
<h2><span class=bndoc-counter>7.6</span>Versioning Bundles</h2>
<p>Versioning bundles usually requires bumping the version every time it is placed in a repository. When package versioning is used, the bundle version is only important for tracking an artifact.</p>
<p>! Baselining</p>
<p>Requires 2.2.0</p>
<p>Baselining compares the public API of a bundle with the public API of another bundle. It can be run from the command line (see <code>bnd help baseline</code>) or always after a project is build. For a project, the previous version of a bundle is found in the ''baseline repository'', this is called the ''baseline''.</p>
<p>APIs are compared for backward compatibility using the semantic versioning rules defined in this chapter. Baselining is aware of the @ConsumerType and @ProviderType rules. Proper versions are calculated and suggested.</p>
<p>It is possible to baseline a project with the following instructions:</p>
<p>||<code>-baseline</code>||PARAMETERS||The parameters specify glob patterns matched agains the bsns. The version attribute can indicate a version. A project  is only baselined if the name of the parameter matches and an appropriate version can be found in the baseline repo or the the release repo||
||<code>-baselinerepo</code>||Repo name||The repository that must be used for baselining||
||<code>-releaserepo</code>||Repo name||Repository to use when no <code>-baselinerepo</code> is specified.||</p>
<h3>>Example baselining Project Instructions</h3>
<pre>  Bundle-Version: 1.0.2
  -baseline: *
  -baselinerepository: Released
</pre>
<p>In this example, the last version in the Released repository for the project's bsn is supposed to be the previous version. Make sure you do not always release snapshot versions to this repository since this will create false changes. During a development cycle, the baseline version must remain constant until the current development bundle is released, at which points it becomes the baseline of the next cycle.</p>
<p>Since an error is raised when the baselining detects an semantic version violation it is possible to release a snapshot in a build only when there is a correctly baselined bundle built.</p>

</section><section>
	<h1><span class=bndoc-counter>8</span>Service Components</h1>
<p>''Version 1.42''</p>
<p>The Service-Component header is compatible with the standard OSGi header syntax. Any element in the list that does not have attributes must have a resource in the JAR and is copied as is to the manifest. However, simple components can also be defined inline, and it is even possible to pickup annotations.</p>
<p>The syntax for these component definitions is:</p>
<p>component ::= <name> ( ';' parameter ) *
parameter ::= provide | reference | multiple | optional
| reference | properties | factory | servicefactory
| immediate | enabled | implementation
| activate | deactivate | modified | configuration-policy
| version | designate</p>
<p>reference ::= <name> '=' <interface-class>
( '(' <target-filter> ')')? cardinality?
cardinality ::= '?' | '<em>' | '+' | '~'
provide  ::= 'provide:=' LIST
multiple  ::= 'multiple:=' LIST
optional  ::= 'optional:=' LIST
dynamic   ::= 'dynamic:=' LIST
designate  ::= ( 'designate' | 'designateFactory' ) CLASS
factory   ::= 'factory:=' true | false
servicefactory := 'servicefactory:=' true | false
immediate ::= 'immediate:=' true | false
enabled   ::= 'enabled:=' true | false
configuration-policy ::= "configuration-policy:='
( 'optional' | 'require' | 'ignore' )
activate  ::= 'activate:=' METHOD
modified  ::= 'modified:=' METHOD
deactivate::= 'deactivate:=' METHOD
implementation::= 'implementation:=' <implementation-class>
properties::= 'properties:=' key '=' value  [=\=]
( ',' key '=' value ) *
key       ::= NAME (( '@' | ':' ) type )?
value     ::= value ( '|' value )</em></p>
<p>If the name of the component maps to a resource, or ends in XML, or there are attributes set, then that clause is copied to the output Service-Component header.</p>
<p>If the name can be expanded to one or more classes that have component annotations (they must be inside the JAR), then each of those classes is analyzed for its component annotations. These annotations are then merged with the attributes from the header, where the header attributes override annotations. The expansion uses the normal wildcard rules. For example, <code>biz.aQute.components.*</code> will search for component annotated classes in the  <code>biz.aQute.components</code> package or one of its descendants. The classes must be present in the JAR. If no classes with annotations can be found for the <code>name</code> then it is assumed to be name or implementation class name without annotations.</p>
<p>The name of the component is also the implementation class (unless overridden by the implementation: directive). It is then followed with a number of references and directives. A reference defines a name that can be used with the <code>locateService</code> method from the <code>ComponentContext</code> class. If the name starts with a lower case character, it is assume to be a bean property. In that case the reference is augmented with a <code>set&lt;Name&gt;</code> and <code>unset&lt;Name&gt;</code> method according to the standard bean rules. Bnd will interpret the header, read the annotations if possible, and create the corresponding resources in the output jar under the name <code>OSGI-INF/&lt;id&gt;.xml</code>.</p>
<p>Annotations are only recognized on the component class, super classes are not inspected for the components.</p>
<p>The supported annotations in the <code>aQute.bnd.annotations.component</code> package are:</p>
<p>||!Component||
Annotated the class, indicates this class is required to be a component. It has the following properties:</p>
<p>||  provide||Class[]||Service interfaces, the default is all directly implemented interfaces||
||name     ||String||Name of the component||
||factory  ||Boolean||Factory component||
||servicefactory||Boolean||Service Factory||
||immediate||Boolean||Immediate activation||
||designate||CLASS||Designate a class as a [[MetaType]] interface used for configurations for unitary configurations, see [[#metatype]]. This changes the default of the configurationPolicy to <code>require</code>.||
||designateFactory||CLASS||Designate a class as a [[MetaType]] interface used for configurations for factory configurations, see [[#metatype]]. This changes the default of the configurationPolicy to <code>require</code>.||
||configurationPolicy||OPTIONAL, REQUIRE, IGNORE||Configuration Policy||
||enabled||Boolean||Enabled component||
||properties||String[]||Properties specified as an array of <code>key=value</code>. The property type can be specified in the key as <code>name:Integer</code>. The value can contain multiple values, the parts must then be separated by a vertical bar ('|') or a line feed (\n), for example <code>properties = {"primes:Integer==1|2|3|5|7|11"</code>}.||</p>
<p>||!Reference||
On a method. Indicates this method is the activate method. It has the following attributes</p>
<p>||name||String||Name of the reference. Default this is the name of the method without set on it.||
||service||Class||The service type, default is the argument type of the method. The unset method is derived from this name. I.e. setXX will have an unsetXX method to unset the reference.||
||type||Character||Standard cardinality type '?', '*', '+','~'||
||target||String||A filter expression applied to the properties of the target service||
||unbind||String||Optional name of the unbind method. By default this is the same name as the bind method name but with set/add replaced with unset/remove. E.g. setFoo() bind method becomes unsetFoo() unbind method.||</p>
<p><code>@Reference</code> automatically sets the bind method. The unbind method is set by using a derived name from the bind method or providing it with the name of the unbind method. The following name patterns are supported:</p>
<p>||!bind||!unbind||
||<code>setX</code> ||<code>unsetX</code>||
||<code>addX</code> ||<code>removeX</code>||
||<code>xxxX</code> ||<code>unxxxX</code>||
For example:
@Reference
protected void setFoo(LogService l) { ... }
protected void unsetFoo(LogService l) { ... }
If you want to override this, use
@Reference(unbind="IRefuseToCallMyMethodUnFoo");
protected void foo(LogService l) {}
protected void IRefuseToCallMyMethodUnFoo(LogService l) {}
Unfortunately Java has no method references so it is not type safe.A non existent <code>@UnReference</code> annotation is not very useful because that still requires linking it up symbolically to the associated <code>@Reference</code>.</p>
<p>||!Activate, Modified, and Deactivate||
The life cycle methods. These annotations have no properties.</p>
<p>Assume the JAR contains the following class:</p>
<p>package com.acme;
import org.osgi.service.event.<em>;
import org.osgi.service.log.</em>;
import aQute.bnd.annotation.component.*;</p>
<p>@Component
public class AnnotatedComponent implements EventHandler {
LogService log;</p>
<pre>@Reference
void setLog(LogService log) { this.log=log; }

public void handleEvent(Event event) {
  log.log(LogService.LOG_INFO, event.getTopic());
}
</pre>
<p>}</p>
<p>The only thing necessary to register the Declarative Service component is to add the following Service-Component header:</p>
<p>Service-Component: com.acme.*</p>
<p>This header will look for annotations in all com.acme sub-packages for an annotated component. The resulting XML will look like:</p>
<p>OSGI-INF/com.acme.AnnotatedComponent.xml:
<?xml version='1.0' encoding='utf-8'?>
<component name='com.acme.AnnotatedComponent'>
<implementation class='com.acme.AnnotatedComponent' />
<service>
<provide interface='org.osgi.service.event.EventHandler' />
</service>
<reference name='log'
interface='org.osgi.service.log.LogService'
bind='setLog'
unbind='unsetLog' />
</component></p>
<p>The following example shows a component that is bound to the log service via the setLog method without annotations:<br  /></p>
<p>Service-Component=aQute.tutorial.component.World; [=\=]
log=org.osgi.service.log.LogService<br  /></p>
<p>The Service Component Runtime (SCR) offers a variety of options on the reference. Some options like the target can be used by adding the target filter after the interface name (this likely requires putting quotes around the interface name+filter).</p>
<p>References can be suffixed with the following characters to indicate their cardinality:</p>
<p>Char          Cardinality    Policy
?             0..1           dynamic
*             0..n           dynamic
+             1..n           dynamic
~             0..1           static
1              static</p>
<p>For a more complex example:</p>
<p>Service-Component=aQute.tutorial.component.World; [=\=]
log=org.osgi.service.log.LogService?; [=\=]
http=org.osgi.service.http.HttpService; [=\=]
PROCESSORS="xierpa.service.processor.Processor(priority>1)+"; [=\=]
properties:="wazaabi=true"</p>
<p>The previous example will result in the following service component in the resource <code>OSGI-INF/aQute.tutorial.component.World.xml</code>:<br  /></p>
<p><?xml version="1.0" encoding="utf-8" ?>
<component name="aQute.tutorial.component.World">
<implementation class="aQute.tutorial.component.World"  />
<reference name="log"
interface="org.osgi.service.log.LogService"
cardinality="0..1"
bind="setLog"
unbind="unsetLog"
policy="dynamic"  />
<reference name="http"
interface="org.osgi.service.http.HttpService"
bind="setHttp"
unbind="unsetHttp"  />
<reference name="PROCESSORS"
interface="xierpa.service.processor.Processor"
cardinality="1..n"
policy="dynamic"
target="(&(priority>=1)(link=false))"  />
</component></p>
<p>The description also supports the immediate, enabled, factory, target, servicefactory, configuration-policy, activate, deactivate, and modified attributes. Refer to the Declarative Services definition for their semantics.</p>
<p>If any feature of the V1.1 namespace is used, then bnd will declare the namespace in the <code>component</code> element. A specific namespace version can be set with the <code>version</code> directive. This detection only works when components are used.</p>
<p>Bnd also supports setting the policy and cardinality through the following directives:</p>
<p>multiple:= LIST    names of references that have x..n
optional:= LIST    names of references that have 0..x
dynamic:=  LIST    names of references that are dynamic</p>
<h2><span class=bndoc-counter>8.1</span>Components and Metatype</h2>
<p>The Service Component Runtime works closely together with the Configuration Admin to allow the components to be controlled through configuration. Configuration Admin knows two types of configuration:</p>
<ul>
<li>Unitary</li>
<li>Factory</li>
</ul>
<p>A unitary configuration can be set and changed but there is at most one of them. A Factory configuration can be used to create multiple instances of the same component. A component has a configuration policy that defines when no configuration is set.</p>
<ul>
<li>optional - If no configuration is set (either unitary or factory) then the component is still created.</li>
<li>require - This requires a unitary configuration to be set or one or more factory configurations before a component is created.</li>
<li>ignore - Ignore configuration information</li>
</ul>
<p>A related standard is the Metatype standard. The Metatype Service provides a repository of property descriptors. Bundles can provide these descriptors in their bundles in the OSGI-INF/metatype directory. There are tools, like the [Felix Webconsole][http://felix.apache.org/site/apache-felix-web-console.html], that can provide an editing window for a configuration that is typed with a metatype description.</p>
<p>In practice, this is a powerful model that provides a lot of configurability for your components with easy editing but getting it all right is not trivial. To make this easier, bnd has made it ease to use configurations.</p>
<p>In this model, configurations are declared in an interface. For example, the following interface defines a simple message:</p>
<p>interface Config {
String message(); // message to give
}</p>
<p>To create a component that can work with this config, we need to designate that interface as the configuration interface for a component.</p>
<p>@Component(designate=Config.class)
public class BasicComponent {
Config config;</p>
<pre>  @Activate void activate(Map&lt;String,Object&gt; props) {
     config = Configurable.createConfig(props);
     System.out.println("Hi " + config.message());
  }

  @Deactivate void deactivate() {
     System.out.println("Bye " + config.message());
  }
</pre>
<p>}</p>
<p>This is an immediate component because it does not implement a service interface. It also requires a configuration because we have not specified this explicitly. When you use designate (or designateFactory) the default becomes require. This means that your component will only be created when there is actually configuration for it set.</p>
<p>To run this component, make sure you have the Felix Webconsole running and the MetaType service installed. In the Webconsole, you can click on
'''Configuration''', your component should be listed on this page. By Clicking on the component with the name '''Basic Component Config''' you get an editor window.</p>
<p>The editor is aware of the proper types, it uses the [[MetaType]] standard to describe the properties. bnd uses the type information on the interface as well as the optional Metadata annotations to create a rich description that allows the web console to provide a good editor.</p>
<p>You can fill in the message in the ''Message'' field. If you save the editor, your component prints the message with "Hi" in front of it. Deleting the configuration will print the message with "Bye".</p>
<p>If you change the message, you will see that the component is first deactivated and then reactivated again. This is the only possibility for the SCR because the component has not implemented a modified method. Adding the following method will change this, now changes to the configuration are signaled to the component and the component can continue to work. This is more complicated then recycling the component but it can create a more optimized system.</p>
<p>@Modified
void modified( Map<String,Object> props) {
// reuse activate method
activate(props);
}</p>
<p>It is also possible to take advantage of the configuration factories. In this model</p>
<p>An example, that implements a simple socket server on a configurable port and returns a message when a telnet session is opened to that port can be found on [Github][https://github.com/bnd/aQute/blob/master/aQute.metatype/src/aQute/metatype/components/ServerSocketComponent.java].</p>

</section><section>
	<h1><span class=bndoc-counter>9</span>Metatype</h1>
<p>''Version 1.42''</p>
<p>The OSGi Metatype specification provides a language to describe configuration information in an XML file. However, XML is cumbersome to use and eXtreMeLy error prone, and refactoring often finds it hard to change references in XML text files. Especially with DS components managing the relations can be complex, see [[Components]]</p>
<p>For this reason, bnd provides annotations to define the XML based on a ''configuration'' interface. For example, the following interface defines a simple metatype:</p>
<p>package com.acme;
import aQute.bnd.annotation.metatype.*;</p>
<p>@Meta.OCD interface Config {
int port();
}</p>
<p>To turn this into an XML file, the bnd file must contain:</p>
<p>-metatype: *</p>
<p>The wild card will search through the whole bundle but it is possible to limit this to a restricted set of packages to speed up the processing. For example:</p>
<p>-metatype: <em>Metatype</em>, com.libs.metatypes</p>
<p>If the previous <code>Config</code> interface is present in the output, the output will also contain an XML file at <code>OSGI-INF/metatype/com.acme.Config.xml</code>. This file will look as follows:</p>
<p><metatype:MetaData
xmlns:metatype='http://www.osgi.org/xmlns/metatype/v1.1.0'>
<OCD
name='Config'
id='aQute.metatype.samples.Config'
localization='aQute.metatype.samples.Config'>
<AD
name='Port'
id='port'
cardinality='0'
required='true'
type='Integer' />
</OCD>
<Designate pid='aQute.metatype.samples.Config'>
<Object ocdref='aQute.metatype.samples.Config' />
</Designate>
</metatype:MetaData></p>
<p>bnd leverages the rich type information the Java class files contain. It inspects the returns types and from this it automatically calculates the AD type as well as the cardinality. For example, a method like:</p>
<p>List<Integer> ints()</p>
<p>Provides an AD of:</p>
<pre>&lt;AD 
  name='Ints' 
  id='ints' 
  cardinality='-2147483648' 
  required='true' 
  type='Integer'/&gt;
</pre>
<h2><span class=bndoc-counter>9.1</span>Naming</h2>
<p>bnd attempts to make the names of the OCD and AD human readable by un-camel-casing the id. This means that it uses the upper cases in the id to decide where to use spaces. It also attempts to replace '_' characters with spaces and removes '$'. If the result is not what is wanted, the name can always be explicitly set with the AD.name() field.</p>
<p>The id of the properties is by default derived from the method name. The name space of methods is restricted by the Java language both in character set as well as by the reserved keywords. Therefore, bnd mangles the name of the method to allow the method name to be adapted to common practices in proeprty names.</p>
<ul>
<li>'$' is removed from the name unless it is followed by another '$', in that case it is a single '$'. This can be used to use Java keywords as a name. For example, <code>$new</code> maps to the <code>new</code> name. To make the name <code>$x</code>, use a method with the name <code>$$x</code>.</li>
<li>'<em>' is replaced with '.' unless it is followed by another '</em>', in that case it becomes a single '_'. This is useful for dotted names (<code>a.b.c</code> comes from <code>a_b_c</code>) and to indicate private properties, that is properties that start with a '.'. For example, <code>_secret</code> maps to <code>.secret</code> and this will be a property that is not registered as a service.</li>
</ul>
<p>For example:</p>
<p>@OCD
interface Config {
String _password(); // .password - will not be registered as a service
String $new();      // new - keyword
}</p>
<h2><span class=bndoc-counter>9.2</span>@Meta.OCD</h2>
<p>The OCD annotation is necessary to know that an interface is a Metatype interface. It should be used preferably without any parameters (they all have good defaults). However, each default is possible to override. The following table discusses the fields:</p>
<p>||<code>name</code>||String||A human readable name of the component, can be localized if it starts with a % sign. The default is a string derived from the id where _, $, or camel casing is used to provide spaces.||
||<code>id</code>||String||The id of the OCD, this will also be used for the pid of the Designate element.||
||<code>localization</code>||String||The localization id of the metatype. This refers to a properties file in the OSGI-INF/i10l/<localization>.properties file that can be augmented with locale information.||
||<code>description</code>||String||A human readable description that can be localized. Default is empty.||
||<code>factory</code>||String||Will treat this OCD as intended to be for a factory configuration. The default is <code>false</code>||</p>
<h2><span class=bndoc-counter>9.3</span>@Meta.AD</h2>
<p>The <code>AD</code> is an optional annotation on methods of a OCD interface. The annotation makes it possible to override the defaults and provide extra information.</p>
<p>||<code>name</code>||String||A human readable name of the attribute, can be localized if it starts with a % sign. The default is a string derived from the method name where <em>, $, or camel casing is used to provide spaces.||
||<code>id</code>||String||The id of the attribute. By default this is the name of the method||
||<code>description</code>||String||A human readable description that can be localized. Default is empty.||
||<code>type</code>||String||The type of the attribute. This must be one of the types defined in the Metatype specification. By default the type will be derived from the return type of the method. If no applicable type can be found then the <code>String</code> type is used as final default.||
||<code>cardinality</code>||int||The cardinality of the attribute. If this is negative its absolute indicates maximum number of elements in a Vector. If it is positive it indicates the maximum number of values in an array. Zero indicates a scalar. If not provided, bnd will calculate the cardinality based on the return type. Collections will have a negative large value and arrays have a positive large value.||
||<code>min</code>||String||The minimum value allowed for this attribute. There is no default.||
||<code>max</code>||String||The maximum value allowed for this attribute. There is no default.||
||<code>deflt</code>||String||The default initial value. The default for this is an empty String||
||<code>required</code>||boolean||Indicates if this attribute is required. The default is that attributes are required.||
||<code>optionLabels</code>||String[]||Labels for any values specified in <code>optionValues</code>. The default value is unset if there are no optionValues are defined. If these are defined, then the labels are calculated from the values by making </em>, $ into spaces and providing spaces between camel cased words in the values.||
||<code>optionValues</code>||String[]||Optional values. If this field is not set and the return type is an enum type then the values are calculated from the enum members.||</p>
<h2><span class=bndoc-counter>9.4</span>Runtime conversions</h2>
<p>The type support the OSGi Metatype specification is limited to the primitives and strings. So what happens when you use another type? During the build phase, bnd will revert to a 'String' Metatype type. This means that those special types are going to be strings in the dictionary. However, the aQute.bnd.annotation.metatype package contains a helper class that simplifies the usage of properties in runtime. It has a @createConfigurable(Class<T> c, Map<?,?> props)`. This method returns an object that implements the given configuration interface. The implementation of these methods uses the properties to provide a value. That is, calling the method abc() on this interface will attempt to find the property "abc". It will then use the actual return type of the method to do conversion from the type in the properties to the return type. This takes generic information into account when present.</p>
<p>For example:</p>
<p>@Meta.OCD
interface Config {
URI[] uris();
}</p>
<p>public void updated( Map<String,Object> props) {
config = Configurable.createConfigurable(Config.class,props);
for ( URI URI : config.uris() ) {
...
}
}</p>
<p>The Metatype specification does not support URIs, so how does this work? Lets first look at the AD:</p>
<pre>&lt;AD 
 name='uris' 
 id='uris' 
 cardinality='2147483647' 
 required='true' 
 type='String'/&gt;
</pre>
<p>Any editor will therefore put an array of strings (String[]) in the properties. When the proxy gets the string, it will therefore have to convert from the String[] -> URI[]. In this case, the URI has a String constructor and is used to do the conversion from String to URI. The converter can handle general array to collection, collection to array, and as indicated, any conversion to an object that has a String constructor.</p>
<p>For convenience there are a number of built int conversions provided that cannot leverage the String constructor:</p>
<ul>
<li>Pattern - Allows regular expression to be set</li>
<li>Class<?> - Tries to load a class through the class loader of the configuration interface</li>
<li>boolean - Converts wrappers and primitive boolean to 0 (false) or non-0 (true) and vice versa.</li>
<li>Numbers - Converts any known Number subclass to another Number subclass, including the primitive types.</li>
<li>Enums - If the return type is an enum, it will use the <code>valueOf</code> method to get an instance.</li>
</ul>
<h2><span class=bndoc-counter>9.5</span>Example</h2>
<p>The following example shows a very simple metatype configuration interface:</p>
<p>package aQute.metatype.samples;
import aQute.bnd.annotation.metatype.Meta.*;
@OCD
public interface Config {
int port();
}</p>
<p>If the bnd.bnd file contains:</p>
<p>-metatype: *</p>
<p>Then bnd will detect this class as a Metatype and it generates the following XML in `OSGi-INF/metatype/aQute.metatype.samples.Config.xml</p>
<p><?xml version='1.0'?>
<metatype:MetaData
xmlns:metatype='http://www.osgi.org/xmlns/metatype/v1.1.0'>
<OCD
name='Config'
id='aQute.metatype.samples.Config'<br  />
localization='aQute.metatype.samples.Config'>
<AD
name='Port'
id='port'
cardinality='0'
required='true'
type='Integer' />
</OCD>
<Designate pid='aQute.metatype.samples.Config'>
<Object ocdref='aQute.metatype.samples.Config' />
</Designate>
</metatype:MetaData></p>
<p>As usual, XML does an outstanding job in obfuscating the interesting parts. If you're using the Apache Felix Webconsole (and if not, why not?) then you can edit this metatype on the web:</p>
<p>%width=500px% http://www.aqute.biz/uploads/Bnd/webconsole.png</p>
<p>This metatype can now be used in a simple example that prints the port number:</p>
<p>package aQute.metatype.samples;
import java.util.<em>;
import org.osgi.service.cm.</em>;
import aQute.bnd.annotation.component.<em>;
import aQute.bnd.annotation.metatype.</em>;</p>
<p>@Component(properties="service.pid=aQute.metatype.samples.Config")
public class Echo implements ManagedService {</p>
<pre>public void updated(Dictionary properties) 
  throws ConfigurationException {
  if ( properties != null ) {
    Config config = Configurable.createConfigurable(
      Config.class, properties);
    System.out.println(config.port());
  }
}
</pre>
<p>}</p>
<p>The editor can get quite rich with the metatype information. For example:</p>
<p>http://www.aqute.biz/uploads/Bnd/complex.png</p>
<p>This information came from the following Meta interface:</p>
<p>interface SampleConfig {
String _secret();
String $new();
String name();
enum X { A, B, C; }
X x();
int birthYear();
URI uri();
URI[] uris();
Collection<URI> curis();
Collection<Integer> ints(); // fails on webconsole
}</p>
<p>Though this is a big savings over normal fudging with properties, it gets better. The metatyping is fully integrated with DS. In this example, we're using DS to register the Managed Service but this is not necessary because DS will automatically use the name of a component as the PID. So with a component life can be as easy as:</p>
<p>@Component(designate=Config.class)
public class Echo2 {<br  />
@Activate
void activate(Map<?,?> properties) throws ConfigurationException {
Config config = Configurable.createConfigurable(
Config.class, properties);
System.out.println(config.port());
}
}</p>
<p>No more strings. Components and metatypes are extensively explained in [[Components]].</p>

</section><section>
	<h1><span class=bndoc-counter>10</span>Contracts</h1>

</section><section>
	<h1><span class=bndoc-counter>11</span>Launcher</h1>
<p>bnd integrates an OSGi launcher. This launcher will start a framework and then install and start a list of bundles. The launching environment is described with a number of instructions that start with <code>-run</code>.</p>
<ul>
<li><code>-runfw</code> — Specify the run framework in repository format</li>
<li><code>-runsystemcapabilities</code> —</li>
<li><code>-runbundles</code> — A list of bundles to install in repository format</li>
<li><code>-runvm</code> — VM options. Use a comma to separate different options. E.g. <code>-Dx=4, -Dy=5</code>.</li>
<li><code>-runproperties</code> — System properties for the framework to create</li>
<li><code>-runpath</code> — A list of jars (not required to be bundles) that are put on the classpath and available from the system bundle. Any Export-Package headers are exported.</li>
<li><code>-runsystempackages</code> — An Export-Package list for packages exported by the system bundle.</li>
</ul>

</section><section>
	<h1><span class=bndoc-counter>12</span>Testing</h1>
<p>This section describes how bnd implements a pluggable testing framework. With most tools that use bnd this information is hidden behind a pleasant GUI (sometimes). However, in certain cases it is necessary to understand how bnd handles testing.</p>
<h2><span class=bndoc-counter>12.1</span>Model</h2>
<p>In the classic way testing consists of launching a new VM, dynamically loading the classes to be tested and then running the test framework on those. As this violates module boundaries as if they did not exist there is another way.</p>
<p>In bnd there is a header that allows a bundle to define what tests it contains:</p>
<p>Test-Cases ::= fqn+</p>
<p>Such a bundle therefore exports a number of test cases to the environment. These test cases can then be executed by the tester. The default tester in bnd is the biz.aQute.junit bundle, but this can be overridden because the launcher and the tester are pluggable.</p>
<p>The default tester can run in ''one shot'' mode or in ''automatic'' mode. The one shot mode is used in build tools to fire a test and parse the result. In this mode, the build tool provides the class names to test.</p>
<p>In automatic mode, the default tester creates a list of available bundles with test cases and executes all of them. Automatic mode can then end or it can run in continuous mode. Every time a bundle is started it will run the tests again. Continuous mode is intended for developing test bundles. You just run a framework and edit your test bundle's code. Any changes are saved and deployed, triggering the tests.</p>
<h2><span class=bndoc-counter>12.2</span>Framework Properties for the Default Tester</h2>
<p>The default tester uses the project information to parametrize the tester's runtime component. However, it is also possible to set these runtime parameters explicitly with framework properties when you want to run the framework in automatic mode. The default tester obeys the following framework properties:</p>
<p>||!Property||!Default||!Description||
||<code>tester.port</code>||-||The port to send the JUnit information to in a format defined by Eclipse. If this property is not set, no information is send but tests are still run.||
||<code>tester.host</code>||<code>localhost</code>|| The host to send the JUnit information to in a formatted defined by Eclipse. If this property is not set localhost is assumed.||
||<code>tester.names</code>||||Fully qualified names of classes to test. If this property is <code>null</code> automatic mode is chosen, otherwise these classes are going to be tested and then the test ends.||
||<code>tester.dir</code>||<code>testdir</code>||A directory to put the test reports. If the directory does not exist, no reports are generated. The default is <code>testdir</code> in the default directory. This directory is not automatically created so to see the results it is necessary to ensure such a directory exists. the files in the test directory are usable in Hudson/Jenkins as test reports||
||<code>tester.continuous</code>||<code>false</code>||In automatic mode, no <code>tester.names</code> set, continue watching the bundles and re-run a bundle's tests when it is started.||
||<code>tester.trace</code>||<code>false</code>||Trace the test framework in detail. Default is false, must be set to true or false.||</p>
<h2><span class=bndoc-counter>12.3</span>How to set the Test-Cases Macro Automatically</h2>
<p>The Test-Cases macro can be set by hand but this can become a maintenance nightmare. A very useful macro is the <code>${classes}</code> macro. This macro inspects the JAR and can find all classes that are considered test cases:</p>
<p>Test-Cases = ${classes;CONCRETE;EXTENDS;junit.framework.TestCase}</p>
<p>This example looks for concrete classes that somehow extend the junit base class.</p>
<h2><span class=bndoc-counter>12.4</span>Continuous Testing</h2>
<p>To setup an environment to test continuously, the following launcher can be used:</p>
<p>Test-Cases: ${classes;CONCRETE;EXTENDS;junit.framework.TestCase}
-runfw: org.apache.felix.framework
-buildpath: osgi.core;version=[4.1','5), &#92;
osgi.cmpn,  &#92;
junit.osgi
Private-Package: org.example.tests
-runtrace: true
-runbundles: biz.aQute.junit
-runproperties:  &#92;
tester.trace=true, &#92;
tester.continuous=true, &#92;
tester.dir=testdir</p>
<p>The example setup creates a bundle containing the org.example.tests package and sets the <code>Test-Cases</code> header to all testcases in that package. If you run this setup, it runs the project bundle with the biz.aQute.junit bundle. This tester bundle is parametrized with the <code>tester.*</code> properties to have trace on, test continuous, and put the test reports in <code>./testdir</code>.</p>
<p>You can find a bndtools project that shows this at [Github][https://github.com/bnd/aQute/tree/master/aQute.testing].</p>
<h2><span class=bndoc-counter>12.5</span>Other Tester Frameworks</h2>
<p>The biz.aQute.junit is a normal bundle that gets started from the launcher framework. However, before bnd chooses the default tester, it scans the classpath of the launcher (set with <code>-runpath</code>) for JARs that have the following header set:</p>
<p>Tester-Plugin ::= fqn</p>
<p>The <code>Tester-Plugin</code> header points to a class that must extend the <code>aQute.bnd.build.ProjectTester</code> class. This class is loaded in the bnd environment and not in the target environment. This ProjectTester plugin then gets a chance to configure the launcher as it sees fit. It can get properties from the project and set these in the Project Launcher so they can be picked up in the target environment.</p>
<p>As this is a quite specific area the rest of the documentation is found in the source code.</p>

</section><section>
	<h1><span class=bndoc-counter>13</span>Error Handling</h1>

</section><section>
	<h1><span class=bndoc-counter>14</span>Command Line</h1>
<p>The command line tool can be invoked in several different ways:</p>
<ul>
<li>bnd ''general-options'' ''cmd'' ''cmd-options''</li>
<li>bnd ''general-options'' ''<file>.jar''</li>
<li>bnd ''general-options'' ''<file>.bnd''</li>
</ul>
<p>In this text <code>bnd</code> is used as if it is a command line program. This should be set up as:</p>
<p>java -jar <path to bnd>.jar ...</p>
<p>Work is in progress to simplify this.</p>
<h3>>General Options</h3>
<p>||
||!General Option ||!Description ||
||-failok ||Same as the property -failok. The current run will create a JAR file even if there were errors. ||
||-exceptions ||Will print the exception when the software has ran into a bad exception and bails out. Normally only a message is printed. For debugging or diagnostic reasons, the exception stack trace can be very helpful. ||</p>
<h3>>print ( -verify | -manifest | -list | - all ) * <file>.jar +</h3>
<p>The print function will take a list of JAR file and print one or more aspect of the JAR files. The following aspects can be added.</p>
<ul>
<li><p>-verify - Verify the JAR for consistency with the specification. The print will exit with an error if the verify fails</p>
</li>
<li><p>-manifest - Show the manifest</p>
</li>
<li><p>-list - List the entries in the JAR file</p>
</li>
<li><p>-all - Do all (this is the default)</p>
<p>bnd print -verify *.jar</p>
</li>
</ul>
<h3>>buildx ( -classpath LIST | -eclipse <file> | -noeclipse | -output <file> ) * <file>.bnd +</h3>
<p>The build function will assemble a bundle from the bnd specification. The default name of the output bundle is the name of the bnd file with a .jar extension.</p>
<ul>
<li><p>-classpath - A list of JAR files and/or directories that should be placed on the class path before the calculation starts.</p>
</li>
<li><p>-eclipse - Parse the file as an Eclipse .classpath file, use the information to create an Eclipse's project class path. If this option is used, the default .classpath file is not read.</p>
</li>
<li><p>-noeclipse - Do not parse the .classpath file of an Eclipse project.</p>
</li>
<li><p>-output - Override the default output name of the bundle or the directory. If the output is a directory, the name will be derived from the bnd file name.</p>
<p>bnd buildx -classpath bin -noeclipse -output test.jar xyz.bnd</p>
</li>
</ul>
<p>[[#wrap]]</p>
<h3>>wrap ( -classpath (<file>(','<file>)*)-output <file|dir> | -properties <file> ) * \</h3>
<p>-ignoremanifest? <file>.jar *</p>
<p>The wrap command takes an existing JAR file and guesses the manifest headers that will make this JAR useful for an OSGi Service Platform. If the output file is not overridden, the name of the input file is used with a .bar extension. The default bnd file for the header calculation is:</p>
<p>Export-Package: *
Import-Package: <packages inside the target jar></p>
<p>If the target bundle has a manifest, the headers are merged with the properties.</p>
<p>The defaults can be overridden with a specific properties file.</p>
<ul>
<li><p>-output - Set the output file or directory</p>
</li>
<li><p>-classpath - Sets the classpath as a comma separated list</p>
</li>
<li><p>-properties - Use a special property file for the manifest calculation.</p>
</li>
<li><p>-ignoremanifest - Do not include the manifest headers from the target bundle</p>
<p>bnd wrap -classpath osgi.jar *.jar</p>
</li>
</ul>
<h3>>eclipse</h3>
<p>List the Eclipse information in the current directory.</p>
<p>bnd eclipse
[[#eclipse]]</p>
<h2><span class=bndoc-counter>14.1</span>Eclipse Plugin</h2>
<p>The bnd.jar file is a complete plugin. To install this plugin, place it in the eclipse/plugin directory (or extension directory) of your Eclipse installation and restart (!). The plugin will provides a 'Make Bundle' context menu when you select a file that ends with .bnd. Two menus are shown when you select a JAR file. You can 'Wrap JAR', turning it into a bundle with all imports and exports set (the extension will be .bar), or you can use 'Verify Bundle', and verify the bundle for compliance to the spec. Any errors or warnings are listed in a dialog box.</p>
<p>Additionally, the plugin registers an editor for JAR files. The editor shows the full output of the print command.</p>

</section><section>
	<h1><span class=bndoc-counter>15</span>Ant Tasks</h1>
<p>The <code>bnd.jar</code> file can also be used as an ANT task. The following example shows how you can use it from an ANT file.</p>
<p><target name="build">
<taskdef resource="aQute/bnd/ant/taskdef.properties"
classpath="bnd.jar" />
<bnd
classpath="src"
eclipse="true"
failok="false"
exceptions="true"
files="test.bnd" />
</target></p>
<p>You can set the following attributes:</p>
<p>||
||!Attribute ||!Description ||
||classpath ||Comma separated list of file names. File paths are relative from the ant project file. ||
||eclipse ||True or false. True if the eclipse .classpath file should be read (default). ||
||failok ||Succeed even if there are errors. ||
||exceptions ||If errors occur, show the exception stack trace. ||
||files ||A comma separated list of bnd files ||
||sourcepath||A source path||
||output||Where the output should go||</p>
<p>The following tasks have also been added:
||task name||Class||attributes||
||bndeclipse||EclipseTask||prefix='project.'||
||bndexpand||ExpandPropertiesTask||propertyFile='<file>'||
||bndwrap||WrapTask||jars='<list>', output='<dir>', definitions='<dir>', classpath='<file-list>'||</p>

</section><section>
	<h1><span class=bndoc-counter>16</span>Maven</h1>
<p>The Maven plugin is described at [Felix maven plugin][http://felix.apache.org/site/apache-felix-maven-bundle-plugin-bnd.html]. Defaults for Maven are:</p>
<p>Bundle-SymbolicName: <groupId>.<artifactId>
Bundle-Name:         project.getName();
Bundle-Version:      <version>
Import-Package:      *
Export-Package:      <groupId>.<artifactId>.* (unless Private-package is set)
Bundle-Description:  project.getDescription()
Bundle-License:      project.getLicenses())
Bundle-Vendor:       project.getOrganization();
Include-Resource:    src/main/resources</p>
<p>The repository with the latest plugin is:</p>
<p>http://repo1.maven.org/maven2</p>
<p>Group ID: org.apache.felix
Artifact: maven-bundle-plugin</p>
<p>Other details are found at the Felix site, the plugin is independently maintained by Felix.</p>

</section><section>
	<h1><span class=bndoc-counter>17</span>Gradle</h1>

</section><section>
	<h1><span class=bndoc-counter>18</span>bndtools</h1>

</section><section>
	<h1><span class=bndoc-counter>19</span>Plugins</h1>
<p>Plugins are objects that can extend the functionality of bnd. They are called from inside bnd when a certain action should take place. For example, bnd uses a repository and plugins provide the actual repository implementations. Or for example, the SpringComponent analyzes the Spring files and adds references found in that XML to the imports.</p>
<p>A plugin is defined as:</p>
<p>PLUGIN ::= FQN ( ';' <directive|attribute> )*</p>
<p>The following directive is defined for all plugin:</p>
<p>||<code>path:</code> ||A path to the jar file that contains the plugin. The directory/jar at that location is placed on your classpath for that plugin.||</p>
<p>bnd current supports the following plugin types:</p>
<p>/*<em>
* An optional interface for plugins. If a plugin implements
* this interface then it can receive the remaining attributes
* and directives given in its clause as
* well as the reporter to use.
</em>/
public interface Plugin {
/*<em>
* Give the plugin the remaining properties.
* When a plugin is declared, the clause can contain
* extra properties. All the properties and directives
* are given to the plugin to use.
* @param map attributes and directives for this plugin's clause
</em>/
void setProperties(Map<String,String> map);</p>
<pre>/**
 * Set the current reporter. This is called at init time. 
 * This plugin should report all errors and warnings 
 * to this reporter.
 * @param processor
 */
void setReporter(Reporter processor);
</pre>
<p>}</p>
<p>public interface AnalyzerPlugin {
/*<em>
* This plugin is called after analysis. The plugin
* is free to modify the jar and/or change the classpath
* information (see referred, contained).
* This plugin is called after analysis of the JAR
* but before manifest generation.
*
* @param analyzer
* @return true if the classpace has been modified so that the bundle
*         classpath must be reanalyzed
* @throws Exception
</em>/
boolean analyzeJar(Analyzer analyzer) throws Exception;
}</p>
<p>public interface SignerPlugin {
/*<em>
* Sign the current jar. The alias is the given certificate
* keystore.
*
* @param builder   The current builder that contains the
jar to sign
* @param alias     The keystore certificate alias
* @throws Exception When anything goes wrong
</em>/
void sign(Builder builder, String alias) throws Exception;
}</p>
<p>public interface RepositoryPlugin {
/*<em>
* Return a URL to a matching version of the given bundle.
*
* @param bsn
*            Bundle-SymbolicName of the searched bundle
* @param range
*            Version range for this bundle,"latest"
*            if you only want the
*            latest, or null when you want all.
* @return    A list of URLs sorted on version, lowest version
*            is at index 0.
*            null is returned when no files with the given
*            bsn ould be found.
* @throws Exception
*             when anything goes wrong
</em>/
File[] get(String bsn, String range) throws Exception;</p>
<pre>/**
 * Answer if this repository can be used to store files.
 * 
 * @return true if writable
 */
boolean canWrite();

/**
 * Put a JAR file in the repository.
 * 
 * @param jar
 * @throws Exception
 */
File  put(Jar jar) throws Exception;

/**
 * Return a list of bsns that are present in the repository.
 * 
 * @param  regex if not null, match against the bsn and if 
 *         matches, return otherwise skip
 * @return A list of bsns that match the regex parameter 
 *         or all if regex is null
 */
List&lt;String&gt; list(String regex);

/**
 * Return a list of versions.
 */

List&lt;Version&gt; versions(String bsn);
</pre>
<p>}</p>
<p>public interface MakePlugin {</p>
<pre>/**
 * This plugin is called when Include-Resource detects 
 * a reference to a resource that it can not find in the 
 * file system.
 * 
 * @param builder   The current builder
 * @param source    The source string (i.e. the place 
 *                  where bnd looked)
 * @param arguments Any arguments on the clause in 
 *                  Include-Resource
 * @return          A resource or null if no resource 
 *                  could be made
 * @throws Exception
 */
Resource make(Builder builder, String source, 
      Map&lt;String,String&gt; arguments) throws Exception;
</pre>
<p>}</p>
<p>[[#make]]</p>
<h3>>Make</h3>
<p>Make plugins kick in when the <code>Include-Resource</code> header tries to locate a resource but it cannot find that resource. The <code>-make</code> option defines a number of patterns that are mapped to a make instruction.</p>
<p>For example, if you have</p>
<p>Include-Resource:       com.acme.Abc.ann</p>
<p>If no such resource is found, bnd will look in the -make instruction. This instruction associates a pattern with a plugin type. For example:</p>
<pre>   -make:                  (*.jar); type=xyz; abc=3; def="$1"
</pre>
<p>The first name part of the clause is matched against the unfound resource. All plugins are called sequentially until one returns non-null. The arguments on the -make clause are given as parameters to the make plugin. Normally all Make Plugins should verify the type field.</p>
<p>bnd has a bnd and a copy Make Plugin.</p>
<h3>>Buildin Plugins</h3>
<p>Some plugins are provided by bnd itself.</p>
<p>||aQute.lib.spring.SpringComponent||AnalyzerPlugin||This component will analyze the Spring XML for Spring DM and will add any classes in these files to the referred set of classes.||
||aQute.bnd.make.MakeBnd||MakePlugin||If Include-Resource can't find a referred resource it will use the make plugins to see if any of them can make the requested resource. The MakeBnd has type=bnd. This plugin can recursively call bnd to create embedded jars that are not created sequentially||
||aQute.bnd.make.MakeCopy||MakePlugin||Copies resources from other places in the file system||
||aQute.lib.deployer.FileRepo||RepositoryPlugin||Provides a file based repository.||
||aQute.bnd.maven.MavenRepository||RepositoryPlugin||Provides an interface to a the default maven repository in the user's home directory. Can be used with aQute.bnd.maven.MavenGroup to support converting bundle symbolic names to group and artifact id.||</p>

</section><section>
	<h1><span class=bndoc-counter>20</span>Wrapping</h1>
<p>This is a simple example of wrapping a jar with bnd. The basic idea is to create a recipe (a .bnd file) that collects the different resources in the right way.</p>
<p>For example, you want to wrap the WebSocket server from https://github.com/TooTallNate/Java-WebSocket. Download the binary and the sources in Websocket.jar, Websocket-src.zip. Once you have these files, the following code will create the org.websocket bundle</p>
<h1><span class=bndoc-counter>21</span>Wrapped version of Github project TooTallNate/Java-WebSocket</h1>
<p>Bundle-SymbolicName: org.websocket
Bundle-DocURL: https://github.com/TooTallNate/Java-WebSocket
Bundle-License: https://github.com/TooTallNate/Java-WebSocket/
blob/8ef67b46ecc927d5521849dcc2d85d10f9789c20/LICENSE
Bundle-Description: This repository contains a barebones \
WebSocket server and client implementation written \
in 100% Java. The underlying classes are implemented \
using the Java ServerSocketChannel and SocketChannel \
classes, which allows for a non-blocking event-driven model \
(similar to the WebSocket API for web browsers). \
Implemented WebSocket protocol versions are: Hixie 75, \
Hixie 76, Hybi 10, and Hybi 17</p>
<h1><span class=bndoc-counter>22</span>websocket does not define a version yet :-(</h1>
<p>Bundle-Version: 1.0.2</p>
<p>Include-Resource: @jar/WebSocket.jar, OSGI-OPT/=@jar/WebSocket-src.zip
-exportcontents: org.java_websocket</p>
<p>The documentation headers are optional but very important, just spent the minute to document them since you'll be grateful later.</p>
<p>If the target project does not have a version, makeup a version and maintain it. Notice that in general the recipe will only be used once for each version, it is normally not used in continuous integration builds. However, you normally use it to convert the next version of the project. Crisp versioning is important.</p>
<p>The <code>Include-Resource</code> statement unrolls the jars we downloaded in the root of the JAR and in <code>OSGI-OPT</code>. Since the source code is in the <code>src</code> directory in the  <code>WebSocket-src.zip</code> file, we put it in the new JAR under <code>OSGI-OPT/src</code>. This convention is supported by all IDEs to give you direct access to the bundle's source code. Since the binary and the source are kept together, you always have the correct source code available, and usually automatically. It is so convenient that once you're used to this it is hard to imagine a life without source code.</p>
<p>The binaries and sources are not in the final jar but bnd does not yet know what needs to be exported. This can be indicated with the <code>-exportcontents</code> instruction. It has the same syntax as <code>Export-Package</code> but does not copy from the classpath, it only applies the instruction to the content of the final JAR.</p>
<h2><span class=bndoc-counter>22.1</span>Project</h2>
<p>The easiest way to build these wrappers is to create a project in bndtools called wrappers and create a bnd descriptor for each one. They are then automatically build (look in generated) and you get a lot of help editing the bnd files.</p>
<p>You can also make an ant file but this is not described here (volunteer?). The other possibility is to use bnd from the [[CommandLine]]. In this case the command is:</p>
<p>bnd websocket.bnd</p>
<h2><span class=bndoc-counter>22.2</span>Manifest</h2>
<p>Applying this recipe gives the following manifest in a JAR named <code>org.websocket.jar</code>:</p>
<p>Manifest-Version: 1.0
Bnd-LastModified: 1338190175969
Bundle-Description: This repository contains a barebones WebSocket serve
r and client implementation written in 100% Java. The underlying classe
s are implemented using the Java ServerSocketChannel and SocketChannel
classes, which allows for a non-blocking event-driven model (similar to
the WebSocket API for web browsers). Implemented WebSocket protocol ve
rsions are: Hixie 75, Hixie 76, Hybi 10, and Hybi 17
Bundle-DocURL: https://github.com/TooTallNate/Java-WebSocket
Bundle-License: https://github.com/TooTallNate/Java-WebSocket/blob/8ef67
b46ecc927d5521849dcc2d85d10f9789c20/LICENSE
Bundle-ManifestVersion: 2
Bundle-Name: org.websocket
Bundle-SymbolicName: org.websocket
Bundle-Version: 1.0.2
Created-By: 1.6.0<em>27 (Apple Inc.)
Export-Package: org.java</em>websocket;version="1.0.2"
Include-Resource: @jar/WebSocket.jar, OSGI-OPT/=@jar/WebSocket-src.zip
Private-Package: org.java<em>websocket.handshake,org.java</em>websocket.drafts,
org.java<em>websocket.exceptions,org.java</em>websocket.util,org.java_websocke
t.framing
Tool: Bnd-1.51.0</p>
<h2><span class=bndoc-counter>22.3</span>Extra entries on the Classpath</h2>
<p>One of the great features of bnd is to use export version from other versions to generate the import ranges. This feature requires that the other JARs are on the classpath. In bndtools you can use the -buildpath. However, you always add entries on the class path per bnd descriptor with the -classpath instruction:</p>
<p>-classpath: dependency.jar, other.jar</p>

</section><section>
	<h1><span class=bndoc-counter>23</span>Instructions</h1>
<p>The bnd format is very similar to the manifest. Though it is read with the Properties class, you can actually use the ':' as separator to make it look more like a manifest file. The only thing you should be aware of is that the line continuation method of the Manifest (a space as the first character on the line) is not supported. Line continuations are indicated with the backslash ('' \u005C) as the last character of the line. Lines may have any length.</p>
<p>The most common mistake is missing the escape. The following does not what people expect it to do:</p>
<pre>Header: abc=def,
  gih=jkl
</pre>
<p>This is actually defining 2 headers. You can fold lines by escaping the newline:</p>
<pre>Header: abc=def, \\
  gih=jkl
</pre>
<p>You can add comments with a # on the first character of the line:</p>
<pre># This is a comment
</pre>
<p>White spaces around the key and value are trimmed.</p>
<p>See [  Properties][http://java.sun.com/j2se/1.4.2/docs/api/java/util/Properties.html ] for more information about the format.</p>
<h2><span class=bndoc-counter>23.1</span>Types of Instructions</h2>
<p>There are different instructions in the properties file:</p>
<p>||
||!Type ||!Example ||!Description ||
||Manifest headers ||Bundle-Description: ... ||When the first character is a upper case character. These headers are copied to the manifest or augmented by bnd. ||
||Variables ||version=3.0 ||Variables are lower case headers. Headers can contain references to other headers using macro expansion. Variables are not copied to the manifest. See [Macros][#macros] ||
||Directives ||-include: deflts.bnd ||Directives start with a '-' sign. A directive is an instruction to bnd to do something special. See [Directives][#directives] ||</p>
<p>[[#directives]]</p>
<h2><span class=bndoc-counter>23.2</span>Bnd Directives</h2>
<p>||
||!Directive ||!Format ||!Description ||
||<code>-classpath</code>||[ LIST][#list ] ||Add the listed files to the current class path. The files must be addressed relative to the properties file. The files must be either a JAR file or a directory. For example:\
<code>-classpath= acme.jar, junit.jar, bin</code> ||
||<code>-debug</code>||<code>true|false</code>||Generate debugging information. This will save embedded jar files in the target directory when they are generated on the fly.||
||<code>-donotcopy</code>||[ REGEX][#regex ] ||During copying of files from the classpath, file system, or other places, this filter is used to prevent copies. For example, normally <code>CVS</code> and <code>.svn</code> directories should not be copied. The default is therefore <code>(CVS|.svn)</code>. Example:  \
<code>-donotcopy= (CVS|.svn|.+.bak|~.+)</code> ||
||<code>-exportcontents</code>||[ PATTERN][#LIST|LIST]] of [[#PATTERN ]||The content of this header augments the Export-Package header, but only for the manifest calculation. That is, Export-Package is used to calculate the contents of the JAR, but then this instruction can be used change or add instructions for the manifest generation.||
||-failok ||true | false ||In certain cases, errors should not abort the creation of the bundle. For example test cases often require the creation of an invalid JAR. If this flag is set to true, errors will create a target bundle (when possible) and errors are only listed. When failok is false, the default, any error will not create a target bundle and will delete the bundle file. Example:  \
<code>-failok= true</code> ||
||-include ||[ LIST][#list ] ||This property will include the list of files in the given order. The files are relative from the bnd file itself. If this directive is used inside an included properties file, then the including file is the base. Includes are very useful to keep headers like Bundle-Vendor, Bundle-Copyright central. If the extension of the file is .mf, then the file is parsed as a manifest file. By default, a property defined in an include file override earlier definitions, this implies that any property in the bnd file is overridden if defined in an include file. The include files are read in the order they are listed where later files override earlier files. If there are multiple definitions for the same property, then the last definitions wins. If the path of an included file starts with a ~, then it will '''not''' override earlier set properties.\
You can use properties like /Users/aqute in file names. If the file does not exist, an error is generated. If the filename is prefixed with a '-' sign then no error is generated when the file is absent. For example:  \
\
<code>-include= ~/Users/aqute/deflts.bnd, META-INF/MANIFEST.MF</code>\
<code>-include= a.props, ~META-INF/MANIFEST.MF</code> ||
||<code>-manifest</code>||FILE||Overrides the generation of a manifest and uses the given file instead.||
||<code>-metatype</code>||[Analyzes the classes in the JAR for metatype interfaces (Metadata.OCD annotation). See [[MetaType][#LIST | LIST]] of [[#PATTERN | PATTERN]]|].||
||<code>-nomanifest</code>||false|true||Generate a JAR without a manifest||
||<code>-nodefaultversion</code>||false|true||If true, do not make exported packages without a version inherit the bundle version. See [[Versioning]]||
||<code>-nope</code>||true|false||Do not build a bundle, deprecated use <code>-nobundles=true</code>||
||<code>-nouses</code>||<code>true|false</code>||Do not calculate the <code>uses:</code> directive.||
||<code>-output</code>||PATH||Store the file (if applicable) under the path||
||<code>-plugin</code>||[plugins][#LIST|LIST]] of [[#PLUGIN|PLUGIN]]||Define the plugins that bnd should use. A plugin is a class that is used at certain phases in the bundle generation. That place is defined by the interfaces it implements. Plugins are defined in [[#plugins].||
||<code>-removeheaders</code>||[LIST][#LIST] of string||Removes the given headers from the output manifest. This feature can be useful if you are wrapping a bundle and it contains for example a Require-Bundle header.||
||<code>-snapshot</code>||<code>repl</code>||Replacement for the .SNAPSHOT qualifier used in maven. If a Bundle version uses SNAPSHOT as the qualifier then bnd will replace this with whatever <code>-snapshot</code> is set to. For example:\
\
<code>-snapshot: 201312131817</code>\
\
This replaces the .SNAPSHOT qualifier with a timestamp. If -snapshot is not set the SNAPSHOT qualifier will not be replaced.||
||<code>-sources</code>||<code>true|false</code>||Include sources||
||<code>-wab</code>||[-wablib][#LIST|LIST]] of iclause||Turn a bundle into a Web Archive Bundle (WAB) that can also be used as a WAR, See [[#wab|-wab]] and [[#wablib]||
||<code>-wablib</code>||[-wablib][#LIST|LIST]] of [[#PATTERN|PATTERN]]||Turn a bundle into a Web Archive Bundle (WAB) that can also be used as a WAR, See [[#wab|-wab]] and [[#wablib]||</p>
<h2><span class=bndoc-counter>23.3</span>Headers</h2>
<p>||!Headers ||!Format ||!Description ||
||<code>Bundle-ClassPath</code>|| ||Defines the internal bundle class path, is taken into accont by bnd. That is, classes will be analyzed according to this path. The files/directories on the Bundle-ClassPath must be present in the bundle. Use Include-Resource to include these jars/directories in your bundle. In general you should not use Bundle-ClassPath since it makes things more complicated than necessary. Use the @ option in the Include-Resource to unroll the jars into the JAR.||
||<code>Bundle-\\
ManifestVersion</code>||2 ||The Bundle-ManifestVersion is always set to 2, there is no way to override this. ||
||<code>Bundle-Name</code>|| ||If the Bundle-Name is not set, it will default to the Bundle-SymbolicName. ||
||<code>Bundle-\\
SymbolicName</code>|| ||The Bundle-SymbolicName header can be set by the user. The default is the name of the main bnd file, or if the main bnd file is called bnd.bnd, it will be the name of the directory of the bnd file. An interesting variable is .name:           that will be set to this default name. ||
||<code>Bundle-Version</code>||VERSION ||The version of the bundle. If no such header is provided, a version of 0 will be set. ||
||<code>Conditional-Package</code>||[PATTERN][#LIST|LIST]] of [[#PATTERN] || '''experimental''' Works as private package but will only include the packages when they are imported. When this header is used, bnd will recursively add packages that match the patterns until there are no more additions.||
||<code>Export-Package</code>||[See ExportPackage][#LIST | LIST]] of [[#PATTERN | PATTERN]] ||The Export-Package header lists the packages that the bundle should export, and thus contain. [[#export-package].||
||<code>Fragment-Host</code>|| ||Ignored by bnd||
||<code>Import-Package</code>||[See Import Package][#LIST | LIST]] of [[#PATTERN | PATTERN]] ||The Import-Package header lists the packages that are required by the contained packages. [[#import-package].||
||<code>Include-Resource</code>||[See Include Resource][#LIST|LIST]] of iclause||The Include-Resource instruction makes it possible to include arbitrary resources; it contains a list of resource paths. [[#include-resource].||
||<code>Private-Package</code>||[See Private Package][#LIST | LIST]] of [[#PATTERN | PATTERN]] ||The Private-Package header lists the packages that the bundle should contain but not export. [[#private-package].||
||<code>Require-Bundle</code>|| ||Ignored by bnd||
||<code>Service-Component</code>||[Service Component Header][#LIST | LIST]] of <code>component</code> || See [[#component].||</p>
<h2><span class=bndoc-counter>23.4</span>Basic Types</h2>
<p>||[[#list]][[#LIST]]LIST||A comma separated list. Items should be quoted with '"' if the contain commas. In general, a list item can also define attributes and directives on an item.||
||[[#pattern]][[#PATTERN]]PATTERN||A pattern matches some entity: a package, a directory, etc. Patterns are based on Java regular expressions but are preprocessed before compiled. Any dots ('.') are replaced with . to make them match the input and not act as the 'any character' operator. Any '?' or '<em>' is prefixed with a dot to make it match any character. As an extra convenience, if the string ends with ..</em>, an additional pattern is added to match the complete string with out the ..<em>. The effect is that something like com.acme.</em> matches com.acme and all its sub packages. It is also to negate a pattern by prefixing it with an exclamation mark ('!'). For example:\
<code>Import-Package: !com.sun.*, *</code> \
indicates that any imports to com.sun should not be imported.||
||[[#regex]]REGEX||A regular expressions||</p>
<p>[[#export-package]]</p>
<h2><span class=bndoc-counter>23.5</span>Export-Package</h2>
<p>The bnd definition allows the specification to be done using ''patterns'', a modified regular expression. All patterns in the definition are matched against every package on the [ class path][#CLASSPATH ]. If the pattern is a negating pattern (starts with !) and it is matched, then the package is completely excluded. Normal patterns cause the package to be included in the resulting bundle. Patterns can include both directives and attributes, these items will be copied to the output. The list is ordered, earlier patterns take effect before later patterns. The following examples copies everything on the class path except for packages starting with <code>com</code>. The default for Export-Package is "*", which can result in quite large bundles. If the source packages have an associated version (from their manifest of packageinfo file), then this version is automatically added to the clauses.</p>
<p>Export-Package= !com.*, *</p>
<p>Exports are automatically imported. This features can be disabled with a special directive on the export instruction: <code>-noimport:=true</code>. For example:</p>
<p>Export-Package= com.acme.impl.*;-noimport:=true, *</p>
<p>Bnd will automatically calculate the <code>uses:</code> directive. This directive is used by the OSGi framework to create a consistent class space for a bundle. The Export-Package statement allows this directive to be overridden on a package basis by specifying the directive in an Export-Package instruction.</p>
<p>Export-package = com.acme.impl.*;uses="my.special.import"</p>
<p>However, in certain cases it is necessary to augment the uses clause. It is therefore possible to use the special name <code>&lt;&lt;USES&gt;&gt;</code> in the clause. Bnd will replace this special name with the calculated uses set. Bnd will remove any extraneous commas when the <code>&lt;&lt;USES&gt;&gt;</code> is empty.</p>
<p>Export-package = com.acme.impl.*;uses:="my.special.import,<<USES>>"</p>
<p>Directives that are not part of the OSGi specification will give a warning unless they are prefixed with a 'x-'.</p>
<h3>>Split packages</h3>
<p>Bnd traverse the packages on the classpath and copies them to the output based on the instructions given by the Export-Package and Private-Package headers. This opens up for the possibility that there are multiple packages with the same name on the class path. It is better to avoid this situation because it means there is no cohesive definition of the package and it is just, eh, messy. However, there are valid cases that packages should be merged from different sources. For example, when a standard package needs to be merged with implementation code like the osgi packages sometimes (unfortunately) do. Without any extra instructions, bnd will merge multiple packages where the last one wins if the packages contain duplicate resources, but it will give a warning to notify the unwanted case of split packages.</p>
<p>The <code>-split-package:</code> directive on the Export-Package/Private-Package clause allows fine grained control over what should be done with split packages. The following values are architected:</p>
<p>||<code>merge-first</code>||Merge split packages but do not add resources that come later in the classpath. That is, the first resource wins. This is the default, although the default will generate a warning||
||<code>merge-last</code>||Merge split packages but overwrite resources that come earlier in the classpath. That is, the last resource wins.||
||<code>first</code>||Do not merge, only use the first package found||
||<code>error</code>||Generate an error when a split package is detected||</p>
<p>For example:</p>
<p>Private-Package: test.pack;-split-package:=merge-first</p>
<p>[[#private-package]]</p>
<h2><span class=bndoc-counter>23.6</span>Private Package</h2>
<p>The method of inclusion is identical to the Export-Package header, the only difference is, is that these packages are not exported. This header will be copied to the manifest. If a package is selected by noth the export and private package headers, then the export takes precedence.</p>
<p>Private-Package= com.*</p>
<p>[[#import-package]]</p>
<h2><span class=bndoc-counter>23.7</span>Import Package</h2>
<p>The Import-Package header lists the packages that are required by the contained packages. The default for this header is "*", resulting in importing all referred packages. This header therefore rarely has to be specified. However, in certain cases there is an unwanted import. The import is caused by code that the author knows can never be reached. This import can be removed by using a negating pattern. A pattern is inserted in the import as an extra import when it contains no wildcards and there is no referral to that package. This can be used to add an import statement for a package that is not referred to by your code but is still needed, for example, because the class is loaded by name.</p>
<p>For example:
Import-Package: !org.apache.commons.log4j, com.acme.*,
com.foo.extra</p>
<p>During processing, bnd will attempt to find the exported version of imported packages. If no version or version range is specified on the import instruction, the exported version will then be used though the micro part and the qualifier are dropped. That is, when the exporter is <code>1.2.3.build123</code>, then the import version will be 1.2. If a specific version (range) is specified, this will override any found version. This default an be overridden with the [-versionpolicy][#versionpolicy] command.</p>
<p>If an explicit version is given, then ${@} can be used to substitute the found version in a range. In those cases, the version macro can be very useful to calculate ranges or drop specific parts of the version. For example:</p>
<p>Import-Package: org.osgi.framework;version="[1.3,2.0)"
Import-Package: org.osgi.framework;version=${@}
Import-Package: org.osgi.framework;version="[${version;==;${@}},${version;=+;${@}})"</p>
<p>If an imported package uses mandatory attributes, then bnd will attempt to add those attributes to the import statement. However, in certain (bizarre!) cases this is not wanted. It is therefore possible to remove an attribute from the import clause. This is done with the <code>-remove-attribute:</code> directive or by setting the value of an attribute to !. The parameter of the <code>-remove-attribute</code> directive is an instruction and can use the standard options with !, *, ?, etc.</p>
<p>Import-Package: org.eclipse.core.runtime;-remove-attribute:common,*</p>
<p>Or</p>
<p>Import-Package: org.eclipse.core.runtime;common=!,*</p>
<p>Directives that are not part of the OSGi specification will give a warning unless they are prefixed with a 'x-'.</p>
<p>[[#include-resource]]</p>
<h2><span class=bndoc-counter>23.8</span>Include Resource</h2>
<p>The resources will be copied into the target jar file. The iclause can have the following forms:</p>
<p>iclause    ::= inline | copy
copy       ::= '{' process '}' | process
process    ::= assignment | simple
assignment ::= PATH '=' simple
simple     ::= PATH parameter<em>
inline     ::= '@' PATH ( '!/' PATH? ('/</em><em>' | '/</em>')? )?
parameters ::= 'flatten' | 'recursive' | 'filter'</p>
<p>In the case of <code>assignment</code> or <code>simple</code>, the PATH parameter can point to a file or directory. It is also possible to use the name.ext path of a JAR file on the classpath, that is, ignoring the directory. The <code>simple</code> form will place the resource in the target JAR with only the file name, therefore without any path components. That is, including src/a/b.c will result in a resource b.c in the root of the target JAR.</p>
<p>If the PATH points to a directory, the directory name itself is not used in the target JAR path. If the resource must be placed in a subdirectory of the target jar, use the <code>assignment</code> form. If the file is not found, bnd will traverse the classpath to see of any entry on the classpath matches the given file name (without the directory) and use that when it matches. The <code>inline</code> requires a ZIP or JAR file, which will be completely expanded in the target JAR (except the manifest), unless followed with a file specification. The file specification can be a specific file in the jar or a directory followed by <em></em> or <em>. The </em><em> indicates recursively and the * indicates one level. If just a directory name is given, it will mean </em>*.</p>
<p>The <code>simple</code> and <code>assigment</code> forms can be encoded with curly braces, like <code>{foo.txt}</code>. This indicates that the file should be preprocessed (or filtered as it is sometimes called). Preprocessed files can use the same variables and macros as defined in the [macro section][#macros].</p>
<p>The <code>recursive:</code> directive indicates that directories must be recursively included.</p>
<p>The <code>flatten:</code> directive indicates that if the directories are recursively searched, the output must not create any directories. That is all resources are flattened in the output directory.</p>
<p>The <code>filter:</code> directive is an optional filter on the resources. This uses the same format as the instructions. Only the file name is verified against this instruction.</p>
<p>Include-Resource: @osgi.jar,[=\ =]
{LICENSE.txt},[=\ =]
acme/Merge.class=src/acme/Merge.class</p>
<p>[[#wab]]</p>
<h2><span class=bndoc-counter>23.9</span>Web Archive Bundles</h2>
<p>In OSGi Enterprise 4.2 the concept of Web Archive Bundles were introduced. Web Archive Bundles are 100% normal bundles following all the rules of OSGi. Their speciality is that they can be mapped to a web server following several of the rules of Java Enterprise Edition's Servlet model. The big difference is that the WARs of the servlet model have a rather strict layout of their archive because the servlet container also handles class loading. In OSGi, the class loading is very well specified and it would therefore be wrong to create special rules.</p>
<p>However, the OSGi supports the Bundle-Classpath header. This header allows the organization of the internal layout. It turns out that it is possible to create a valid Web Application Bundle (WAB) that is also a valid Web ARchive (WAR). Being deploy an archive both to OSGi and an application server obviously has advantages. bnd therefore supports a number of instructions that make it easy to create these dual mode archives.</p>
<p>The <code>-wab</code> instruction instructs bnd to move the root of the created archive to WEB-INF/classes. That is, you build your bundle in the normal way,not using the <code>Bundle-ClassPath</code>. The <code>-wab</code> command then moves the root of the archive so the complete class path for the bundle is no inside the WEB-INF/classes directory. It then adjusts the <code>Bundle-ClassPath</code> header to reflect this new location of the classes and resources.</p>
<p>The new root now only contains WEB-INF. In the Servlet specification, the root of the archive is mapped to the server's context URL. It is therefore often necessary to place static files in the root. For this reason, the <code>-wab</code> instruction has the same form as [Include-Resource][#include-resource] header, and performs the same function. However, it performs this function of copying resources from the file system after the classes and resources of the original bundle have been moved to WEB-INF.</p>
<p>For example, the following code creates a simple WAB/WAR:</p>
<p>Private-Package:   com.example.impl.*
Export-Package:    com.example.service.myapi
Include-Resource:  resources/
-wab:              static-pages/</p>
<p>The layout of the resulting archive is:</p>
<p>WEB-INF/classes/com/example/impl/
WEB-INF/classes/com/example/service/myapi/
WEB-INF/classes/resources/
index.html // from static-pages</p>
<p>The <code>Bundle-ClassPath</code> is <code>WEB-INF/classes</code>.</p>
<p>WARs can carry a WEB-INF/lib directory. Any archive in this directory is mapped to the class path of the WAR. The OSGi specifications do not recognize directories with archives it is therefore necessary to list these archives also on the <code>Bundle-ClassPath</code> header. This is cumbersome to do by hand so the <code>-wablib</code> command will take a list of paths.</p>
<p>Private-Package:   com.example.impl.*
Export-Package:    com.example.service.myapi
Include-Resource:  resources/
-wab:              static-pages/
-wablib:           lib/a.jar, lib/b.jar</p>
<p>This results in a layout of:</p>
<p>WEB-INF/classes/com/example/impl/
WEB-INF/classes/com/example/service/myapi/
WEB-INF/classes/resources/
WEB-INF/lib/
a.jar
b.jar
index.html ( from static-pages)</p>
<p>The <code>Bundle-ClassPath</code> is now set to <code>WEB-INF/classes,WEB-INF/lib/a.jar,WEB-INF/lib/a.jar</code></p>

</section><section>
	<h1><span class=bndoc-counter>24</span>Macros</h1>
<p>A simple macro processor is added to the header processing. Variables allow a single definition of a value, and the use of derivations. Each header is a macro that can be expanded. Notice that headers that do not start with an upper case character will not be copied to the manifest, so they can be used as working variables. Variables are expanded by enclosing the name of the variable in <code>${&lt;name&gt;}</code> (curly braces) or <code>${&lt;name&gt;}</code> (parenthesis). Additionally, square brackets [], angled brackets <>, double guillemets «», and single guillemets ‹› are also allowed for brackets. If brackets are nested, that is [cac] will return <code>[cac]</code>.</p>
<p>There are also a number of macros that perform basic functions. All these functions have the following basic syntax:</p>
<pre> macro ::= '${' function '}' 
     | '$\[' function '\]'
     | '${' function '}'
     | '${' function '}'

 function ::= name ( ';' argument ) *
</pre>
<p>For example:</p>
<pre>version=1.23.87.200109111023542
Bundle-Version= ${version}
Bundle-Description= This bundle has version ${version}
</pre>
<h2><span class=bndoc-counter>24.1</span>Arguments</h2>
<p>@Since("2.3") Macros can contain arguments. These arguments are available in the expansion as ${0} to ${9}. ${0} is the name of the macro, so the actual arguments start at 1. The name is also available as ${@}. The arguments as an array (without the name of the macro) is available as ${#}. The more traditional * could not be used because it clashes with wildcard keys, it means ALL values.</p>
<p>For example:</p>
<pre>foo: Hello ${1} -&gt; ${foo;Peter} -&gt; "Hello Peter"
</pre>
<h2><span class=bndoc-counter>24.2</span>Wildcarded Keys</h2>
<p>Keys can be wildcarded. For example, if you want to set -plugin from different places, then you can set the <code>plugin.xxx</code> properties in different places and combine them with <code>-plugins=</code>.</p>
<h2><span class=bndoc-counter>24.3</span>Types</h2>
<p>@TODO</p>
<h2><span class=bndoc-counter>24.4</span>Base Macros</h2>
<p>The following macros are always available.</p>
<h2><span class=bndoc-counter>24.5</span>Build Macros</h2>
<h3>>`bsn                                                                                      {#bsn}</h3>
<p>Return the current Bundle Symbolic Name assumed by the code. This tries to load the current <code>Bundle-SymblicName</code> property, or reverts an inferred name from the file system.</p>
<pre>local = ${bsn}
</pre>
<h2><span class=bndoc-counter>24.6</span>Project Macros</h2>
<pre>basename;arg
</pre>
<p><td><code>arg ( ';' arg )*</code></td>
<td>Return a comma separated list with all the file names (not directory) of the arguments. Non existent files are skipped.</td></p>
<p>[[#cat]]<code>cat</code>
<td><code>arg</code></td>
<td>If arg is a directory, return the contents of the directory. If it is a file, return the contents of the file.</td></p>
<p>[[#classes]]<code>classes</code>
<td>QUERY</td>
<td>Provides a query function to find classes to fulfill certain criteria. See the [classes][#classesx] macro</td></p>
<p>[[#def]]<code>def</code>
<td><code>arg</code></td>
<td>Provide the empty string if arg is not defined, otherwise it provides the value of the property <code>arg</code>.</td></p>
<p>[[#dir]]<code>dir</code>
<td>`arg ( ';' arg ) *</td>
<td>Get the directory names of the arguments in a comma separated format. For example,  should provide the directory path (absolute) of the directory that contains the project</td></p>
<p>[[#env]]<code>env</code>
<td>; name</td>
<td>Provide the value of the given environment variable</td></p>
<p>[[#error]]<code>error</code>
<td><code>arg ( ';' arg ) *</code></td>
<td>Generate an error for each <code>arg</code>.</td></p>
<p>[[#if]]<code>if</code>
<td>; condition ; true ( ; false ) ? </td>
<td>If the condition is not empty, the true part is returned, else the false part is returned. If not false part is supplied, the empty string is returned. The condition is trimmed before tested. For example:</td></p>
<p>Comment: Ok</p>
<p>[[#isdir]]<code>isdir</code>
<td><code>arg</code></td>
<td>Returns "true" when arg is an existing directory, otherwise "false".</td></p>
<p>[[#isfile]]<code>isfile</code>
<td><code>arg</code></td>
<td>Returns "true" when arg is an existing file, otherwise "false".</td></p>
<p>[[#filter]]<code>filter</code>
<td>';' list ';' regex</td>
<td>The filter macro iterates over the given list and only includes elements that match the given regular expression (regex). The following example includes only the jar files from the list: \</td>
<code>list= a,b,c,d,x.jar,z.jar \\
List=</code></p>
<p>[[#filterout]]<code>filterout</code>
<td>; list ; regex</td>
<td>The filterout macro iterates over the given list and removes elements that match the given regular expression (regex). The following example strips the jar files from the list:  \</td>
<code>list= a,b,c,d,x.jar,z.jar \\
List= ${filterout:${list};.*\\.jar}</code></p>
<p>[[#findname]]<code>findname</code>
<td>; regex [ ; replacement ]  </td>
<td>Find the paths to any resources that matches the regular expression, replace the name with the replacement of the regex. Notice that the regex is only executed on the name of the resource, that is, without the slashes.</td></p>
<p>[[#findpath]]<code>findpath</code>
<td>; regex [ ; replacement ]  </td>
<td>Find the paths to any resources that matches the regular expression, replace the path with the replacement of the regex. Notice that the regex is executed on the path of the resource, that is, with the slashes.</td></p>
<p>[[#fmodified]]<code>fmodified</code>
<td>; file-path-list </td>
<td>Return the highest modification time of the given file path. The returned value is based on the epoch of Java, it is therefore a long.  \</td>
<code>Last-Modified: long2date;0)</code></p>
<p>[[#githead]]<code>githead</code>
<td></td>
<td>Returns the SHA of the head. This is either HEAD or the contents of the sym-ref. \</td>
<code>Git-HEAD: ${githead}</code>
<td>2.3</td></p>
<p>[[#join]]<code>join</code>
<td>( ; list ) *</td>
<td>Joins a number of lists into one. It may seem that this can be easily accomplished by just placing two macro expansions after each other. The result of this will not be a list, unless a ',' (colon) is placed in between. However, when one of the lists is empty, the colon will be superfluous. The join handles these cases correctly. Any number of lists may be given as arguments. \</td>
<code>List= a,b,c,d,e,f</code></p>
<p>[[#literal]]<code>literal</code>
<td><code>arg</code></td>
<td>Provide a literal macro for arg. For example, <code>${"project"}</code> results in <code>".name:          "</code>. Can be useful if information must be created for other systems that uses the macro syntax.</td></p>
<p>[[#lsa]]<code>lsa</code>
<td><code>dir</code> ( ';' PATTERN ( ',' PATTERN )* )?</td>
<td>Return the contents of the given directory filtered by the patterns. The result is a comma separated list of absolute file names.</td></p>
<p>[[#lsr]]<code>lsr</code>
<td><code>dir</code> ( ';' PATTERN ( ',' PATTERN )* )?</td>
<td>Return the contents of the given directory filtered by the patterns. The result is a comma separated list of relative file names.</td></p>
<p>[[#long2date]]<code>long2date</code>
<td>; long </td>
<td>Parse the long and turn it into a date.  \</td>
<code>Last-Modified: long2date:${fmodified:${files}})</code></p>
<p>[[#maven_version]]<code>maven_version</code>
<td>version</td>
<td>Clean up a maven version so it conforms to the OSGi specification.</td>
<td></td></p>
<p>[[#now]]<code>now</code>
<td></td>
<td>Returns the current Date as string.  \</td>
<code>Created-When: Fri Dec 13 19:17:10 CET 2013</code></p>
<p>[[#osfile]]<code>osfile</code>
<td><code>base (';' PATH )*</code></td>
<td>Return a comma separated list of absolute file paths in the current's OS' format. If the PATH is relative, it is calculated from the base directory.</td></p>
<p>[[#path]]<code>path</code>
<td>LIST (';' LIST )*`</td>
<td>Return a platform specific path (File.pathSeparator) from the given lists.</td></p>
<p>[[#pathseparator]]<code>pathseparator</code>
<td></td>
<td>Returns the current path separator as defined by <code>File.pathSeparator</code></td></p>
<p>[[#permissions]]<code>permissions</code>
<td><code>(all|packages|admin)+</code></td>
<td>Generates a permission file. If packages is specified, it provides PackagePermission for imports and exports. <code>admin</code> adds an AdminPermission, <code>all</code> adds them all</td>
<td></td></p>
<p>[[#range]]<code>range</code>
<td>; ('[' | '(') MASK ',' MASK (']' | ')') [ ; VERSION]</td>
<td>Create a version range from a version. The MASK is defined in [${version}][#version].</td></p>
<p>[[#replace]]<code>replace</code>
<td>; list ; regex ; replacement </td>
<td>Replace all elements of the list that match the regular expression regex with the replacement. The replacement can use the <code>${0-9}</code> back references defined in the regular expressions. The macro uses <code>item.replaceAll(regex,replacement)</code> method to do the replacement.For example, to add a <code>.jar</code> extension to all files listed, use the following: \</td>
<code>List = ${impls}.jar</code></p>
<p>[[#sort]]<code>sort</code>
<td>; list</td>
<td>Sort the given list using string sorting collation. For example: \</td>
<code>List= ${sort:acme.jar, harry.jar, runner.jar, alpha.jar, bugs.jar}</code></p>
<p>[[#system]]<code>system</code>
<td>system cmd</td>
<td>Execute a command via <code>System.exec</code> and return the result as the macro's value.</td></p>
<p>[[#toclassname]]<code>toclassname</code>
<td>; list</td>
<td>Replace a class path (with slashes and class at the end) to a class name (with dots).</td></p>
<p>[[#toclasspath]]<code>toclasspath</code>
<td>; list  [ ; suffix ]</td>
<td>Replace a class name (with dots) to a classpath (with slashes and <code>suffix</code> at the end). The default suffix is <code>.class</code>. The suffix may be empty</td></p>
<p>[[#tstamp]]<code>tstamp</code>
<td> ( date pattern )?</td>
<td>Answer a time stamp based on the pattern. The pattern is defined by the [SimpleDateFormat][http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html]. The default pattern is <code>yyyyMMddHHmm</code>.</td></p>
<p>[[#unique]]<code>unique</code>
<td>; list ( ; list ) *</td>
<td>Split all the given lists on their commas, combine them in one list and remove any duplicates. The ordering is not preserved, see [${sort}][#sort] For example:</td></p>
<p>${unique; 1,2,3,1,2; 1,2,4} ~ "2,4,3,1"</p>
<p>[[#version]]<code>version</code>
<td>; mask ; version</td>
<td>This macro can modify a version by dropping parts from the end, incrementing parts, or decrementing parts. The mask is a string containing from 1 to 4 characters. The characters have the following meaning: \</td>
= the actual version part \
+ increment the actual version part \
- decrement the actual version part \
For example, ${version;=+;1.2.3.q} will become 1.3.</p>
<p>[[#warning]]<code>warning</code>
<td><code>arg ( ';' arg ) *</code></td>
<td>Generate a warning for each <code>arg</code>.</td></p>
<p>(:tableend:)</p>
<p>[[#classesx]]</p>
<h2><span class=bndoc-counter>24.7</span>classes macro</h2>
<p>The classes macro provides a query function in an analyzed bundle. While analyzing, the Analyzer stores each found class on the Bundle-Classpath with some key information. A simple query language is used to query this dictionary. For example, if you want to make a manifest header with all public classes in the bundle:</p>
<p>Public-Classes: ${classes;PUBLIC}</p>
<p>The query language is conjunctive, that is, all entries form an AND. For example, if you want to find all PUBLIC classes that are also not abstract you would do:</p>
<p>PublicConcrete-Classes: ${classes;CONCRETE}</p>
<p>The query can also parameters. This is a pattern that must match some aspect of the class. For example, it is possible to query for classes that extend a certain base class:</p>
<p>Test-Cases: ${classes;CONCRETE;EXTENDS;junit.framework.TestCase}</p>
<p>All pattern matching is based on fully qualified name and uses the globbing model.</p>
<p>The following table specifies what query options there are:</p>
<p><table>
'''Query'''
<td>'''Parameter'''</td>
<td>'''Description'''</td></p>
<p>IMPLEMENTS
<td>PATTERN</td>
<td>The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath</td></p>
<p>EXTENDS
<td>PATTERN</td>
<td>The class must implement at least one interface that matches the given pattern. This takes inheritance into account as long as intermediates can be found the classpath.</td></p>
<p>IMPORTS
<td>PATTERN</td>
<td>The class must use a type from another package that matches the given pattern</td></p>
<p>NAMED
<td>PATTERN</td>
<td>The class fqn must match the given pattern.</td></p>
<p>ANY
<td></td>
<td>Matches any class</td></p>
<p>VERSION
<td>PATTERN</td>
<td>The class format of the given class must match the given version. The version is given as "<major>/<minor>", like "49/0". To select classes that are Java 6, do <code>${classes;VERSION;49/*}</code></td></p>
<p>CONCRETE
<td></td>
<td>Class must not be abstract</td></p>
<p>ABSTRACT
<td></td>
<td>Class must be abstract</td></p>
<p>PUBLIC
<td></td>
<td>Class must be public</td></p>
<p>ANNOTATION
<td>PATTERN</td>
<td>The class must have an annotation that matches the pattern. The set of annotations is all annotations in the class, also the annotations on fields and methods.</td>
(:tableend:)</p>
<h3>>Caveat</h3>
<p>bnd will attempt to use the resources on the classpath if a super class or interface that is referenced from an analyzed class is not in the class space. However, bnd does not require that all dependencies are available on the classpath. In such a case it is not possible to do a complete analysis. For example, if A extends B and B extends C then it can only be determined that A extends C if B can be analyzed.</p>

</section><section>
	<h1><span class=bndoc-counter>25</span>API</h1>
<p>It is quite easy to use bnd from Java, you only need to include biz.aQute.bndlib on your class path. This chapter shows you some samples of how to use bndlib.</p>
<h2><span class=bndoc-counter>25.1</span>Creating a Manifest</h2>
<p>By default, bnd creates a container with resources and then calculates the manifest. However, these phases are separated although they use the same instructions. The following snippet therefore shows how you can create a manifest from an existing file or directory.</p>
<p>Analyzer analyzer = new Analyzer();
Jar bin = new Jar( new File("bin") );  // where our data is
analyzer.setJar( bin );                // give bnd the contents</p>
<p>// You can provide additional class path entries to allow
// bnd to pickup export version from the packageinfo file,
// Version annotation, or their manifests.
analyzer.addClasspath( new File("jar/spring.jar") );</p>
<p>analyzer.setProperty("Bundle-SymbolicName","org.osgi.core");
analyzer.setProperty("Export-Package",
"org.osgi.framework,org.osgi.service.event");
analyzer.setProperty("Bundle-Version","1.0");</p>
<p>// There are no good defaults so make sure you set the
// Import-Package
analyzer.setProperty("Import-Package","*");</p>
<p>// Calculate the manifest
Manifest manifest = analyzer.calcManifest();</p>

</section><section>
	<h1><span class=bndoc-counter>26</span>Developing with bnd</h1>
<p>In general you find the interesting stuff in aQute.lib.osgi.*. Look at the test cases for how the API can be used.</p>
<h2><span class=bndoc-counter>26.1</span>Example Making a Bundle</h2>
<p>Builder b = new Builder();
b.setProperty( EXPORT_PACKAGE, "org.osgi.framework" );
b.addClasspath( new File("jar/osgi.jar") );</p>
<p>Jar jar = b.build();
Manifest m = jar.getManifest();
jar.write( new File(b.getBsn()+".jar"));</p>

</section><section>
	<h1><span class=bndoc-counter>27</span>Error Messages</h1>

</section><section>
	<h1><span class=bndoc-counter>28</span>Frequently Asked Questions</h1>
<ul>
<li><p>[How to Ask a Question][#howToAsk]</p>
</li>
<li><p>[Too Many Imports][#tooManyImports]</p>
</li>
<li><p>[Remove unwanted imports][#removeImports]</p>
</li>
<li><p>[Importing Default Package][#importingDefaultPackage]</p>
</li>
<li><p>[Why No Automatic Bundle-Activator][#automaticActivator]</p>
</li>
<li><p>[How to set the unbind method with @Reference?][#unbindMethod]</p>
</li>
<li><p>[packageinfo or package-info.java][#packageinfo]</p>
</li>
<li><p>[Why are super classes not inspected for annotations?][#supercomps]</p>
</li>
<li><p>[Where do the exported package versions come from?][#exportversions]</p>
</li>
<li><p>[Should I use the Bundle-ClassPath?][#bundleclasspath]</p>
</li>
<li><h2><span class=bndoc-counter>28.1</span>[What Should I use instead of the Bundle-ClassPath?][#bundleclasspath2]</h2>
<p>[[#howToAsk]]</p>
<h2><span class=bndoc-counter>28.2</span>How to ask a question</h2>
<p>You can send a mail to [mail me][http://groups.google.com/group/bndtools-users/|bndtools users]] or [[mailto:Peter.Kriens@aQute.biz].</p>
</li>
</ul>
<hr />
<p>[[#tooManyImports]]</p>
<h2><span class=bndoc-counter>28.3</span>Too Many Imports</h2>
<p>Sometimes bnd reports imports that seem plain wrong. Believe me, they are almost always right. bnd does a thorough analysis of the byte codes in your class files and when it imports something it is almost sure to be a reference in your code. How can you find the culprit? [[Bndtools]] has tooling to drill down into your code. bnd also can print out the JAR and look at the <code>[USEDBY]</code> section to find the package(s) that cause the import.</p>
<p>If there is no package using the imported package, then look at the following places for imports:</p>
<ul>
<li>Spring/Blueprint XML</li>
<li>Bundle Activator</li>
<li>Component annotations or Service-Component headers</li>
</ul>
<p>In the likely case the import is real but unwanted, look at [Unwanted Imports][#removeUnwantedImports].</p>
<hr />
<p>[[#importingDefaultPackage]]</p>
<h2><span class=bndoc-counter>28.4</span>Importing the default package error</h2>
<p>This usually indicates that:</p>
<ul>
<li>You include classes that have compile errors. Some compilers still create class files on errors but they are invalid.</li>
<li>One of the imports caused by Spring, Blueprint, or Service Components are not proper.</li>
</ul>
<hr />
<p>[[#removeUnwantedImports]]</p>
<h2><span class=bndoc-counter>28.5</span>Remove unwanted imports</h2>
<p>If you have an unwanted import than you can remove it from the Import-Package manifest header with the '!' operator:</p>
<p>Import-Package: !com.unwanted.reference.*, *</p>
<p>A usually better way is to make the imports optional:</p>
<p>Import-Package: com.unwanted.reference.*;optional:=true, *</p>
<p>Note the end at the Import-Package statement, that wildcard '*' is crucial for remaining imports, see [No Imports Show Up][#noImports].</p>
<hr />
<p>[[#noImports]]</p>
<h2><span class=bndoc-counter>28.6</span>No Imports Show Up</h2>
<p>The imports that show up in your Import-Package manifest header are controlled by the bnd file's Import-Package instruction. In bnd, the list is a set of patterns that are sequentially applied to your imports as calculated by bnd from the classes, resources, and headers in the JAR.</p>
<p>The default Import-Package bnd instruction is:</p>
<p>Import-Package: *</p>
<p>This imports all referred packages. The most common reasons imports do not appear in the manifest is that the default is overridden and the overrider forgot to add the wildcard '*' at the end. For example, the following is wrong:</p>
<p>Import-Package: com.example; version=1.2</p>
<p>This will create an import for com.example but it ignores all other imports.</p>
<p>Another reason is the exclude operator ('!') that will remove imports. If this is too wild, then no imports are left to insert in the manifest. So the following leads to no imports for any package starting with com.example.</p>
<p>Import-Package: !com.example.*, *</p>
<p>Last but not least, look at the <code>[USEDBY]</code> section of the JAR print out, make sure there are actually references.</p>
<hr />
<p>[[#automaticActivator]]</p>
<h2><span class=bndoc-counter>28.7</span>Why No Automatic Bundle-Activator</h2>
<p>Many people are surprised that bnd does not automatically calculate the Bundle-Activator. Basically, there are the following issues:</p>
<ul>
<li>Not all bundles have a bundle activator</li>
<li>Detecting an activator in the code does not always mean you want one</li>
<li>Detecting means you can find more than one</li>
</ul>
<p>That said, it is possible to automate the Bundle-Activator:</p>
<p>Bundle-Activator: \
${classes;IMPLEMENTS;org.osgi.framework.BundleActivator}</p>
<p>However, if there are multiple Bundle-Activators you will get an error.</p>
<hr />
<p>[[#unbindMethod]]</p>
<h2><span class=bndoc-counter>28.8</span>How to assign an unbind method to a @Reference?</h2>
<p><code>@Reference</code> automatically sets the bind method but how is the unbind method set? Simple, you use a method with a similar name:</p>
<p>||!bind||!unbind||
||<code>setX</code> ||<code>unsetX</code>||
||<code>addX</code> ||<code>removeX</code>||
For example:
@Reference
protected void setFoo(LogService l) { ... }
protected void unsetFoo(LogService l) { ... }
If you want to override this, use
@Reference(unbind="IRefuseToCallMyMethodUnFoo");
protected void foo(LogService l) {}
protected void IRefuseToCallMyMethodUnFoo(LogService l) {}
Unfortunately Java has no method references so it is not type safe.A non existent <code>@UnReference</code> annotation is not very useful because that still requires linking it up symbolically to the associated <code>@Reference</code>.</p>
<p>[[#packageinfo]]</p>
<h2><span class=bndoc-counter>28.9</span>packageinfo or package-info.java?</h2>
<p>Inspired by the osgi-dev thread [JLS][http://www.mail-archive.com/osgi-dev@mail.osgi.org/msg01514.html|Why default version for Export-Package is 0.0.0, not bundle version?]] I'm just a little bit confused about the bnd approach with the file naming "packageinfo". The [[http://java.sun.com/docs/books/jls/third_edition/html/packages.html] already defines "package-info.java" for package relevant infos. Wouldn't it be simplier (less complex) to have only one file for package definitions? So, the bnd tool could manage the package version in "package-info.java", too.</p>
<p>You can use either file. The reason there are two options is that one constituency thinks annotations are the only solution and the other is running pre Java 5 ... Basically if I would have to choose it would be packageinfo because that works anywhere but I expect that you probably would not like that :-)</p>
<p>[[#supercomps]]</p>
<h2><span class=bndoc-counter>28.10</span>Why are superclass not inspected for Component annotations?</h2>
<p>Annotations are not inherited form the component's super classes. The problem is that bnd cannot in all cases can see super classes (and interfaces) because the super class does not have to be available in the build. In runtime you are sure the super class is there, at build time you do not have that luxury. So to make sure, always define your annotations on the actual component class.</p>
<p>[[#exportversions]]</p>
<h2><span class=bndoc-counter>28.11</span>Can't find the source of the version on an Export-Package?</h2>
<p>If no explicit export version is specified in the bnd file then bnd will look in the following places.</p>
<h1><span class=bndoc-counter>29</span>packageinfo file in the package directory (recommended)</h1>
<h1><span class=bndoc-counter>30</span>package-info.java, bnd's Version annotation</h1>
<h1><span class=bndoc-counter>31</span>Manifest of the exporting JAR</h1>
<p>There was a mis-feature in an [older version of the maven plugin][http://www.mail-archive.com/users@felix.apache.org/msg09656.html] that appended the pom version to the exported packages. It looked professional but it was baloney. Versioning a bundle should not version a package automatically, try it and feel the pain. So if you can't find the source of an exported package version you might have an old maven bundle plugin.</p>
<p>[[#bundleclasspath]]</p>
<h2><span class=bndoc-counter>31.1</span>Should I use the Bundle-ClassPath?</h2>
<p>No. It creates unnecessary complexity, it is slower, and it is not necessary. It will also not be compatible with techniques like [PojoSR][http://code.google.com/p/pojosr], something that the OSGi is looking into standardizing.</p>
<p>[[#bundleclasspath2]]</p>
<h2><span class=bndoc-counter>31.2</span>What should I use instead of the Bundle-ClassPath?</h2>
<p>Just use Private-Package and Export-Package, know what goes into your JAR. If you really need to wrap one or more JARs, use the Include-Resource instruction, it has an option to unroll a JAR resource (see [@ option][#include-resource]). This will copy all its contents in the target JAR. The -exportcontents can then be used to export selected packages. Even better is of course to know</p>
<hr />
<p>If an entry is wrong, send a [mail][mailto:bnd@aQute.biz] with the JAR that has the problem. Preferably as small as possible.</p>

</section>
		</article>

    </body>
</html>
