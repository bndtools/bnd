---
title: FAQ - Frequently Asked Questions
layout: default
---

## How to ask a question <a name="howToAsk"/>
You can use the [bnd discourse site](https://bnd.discourse.group) mail list or [mail me](mailto:Peter.Kriens@aQute.biz).

## Too Many Imports <a name="tooManyImports"/>
Sometimes bnd reports imports that seem plain wrong. Believe me, they are almost always right. bnd does a thorough analysis of the byte codes in your class files and when it imports something it is almost sure to be a reference in your code. How can you find the culprit? Bndtools has tooling to drill down into your code. bnd also can print out the JAR and look at the `[USEDBY]` section to find the package(s) that cause the import.

If there is no package using the imported package, then look at the following places for imports:

* Spring/Blueprint XML
* Bundle Activator
* Component annotations or Service-Component headers

In the likely case the import is real but unwanted, look at [Unwanted Imports](?#removeUnwantedImports).

## Importing the default package error <a name="importingDefaultPackage"/>
This usually indicates that:

* You include classes that have compile errors. Some compilers still create class files on errors but they are invalid.
* One of the imports caused by Spring, Blueprint, or Service Components are not proper.

## Remove unwanted imports <a name="removeUnwantedImports"/>
If you have an unwanted import than you can remove it from the Import-Package manifest header with the '!' operator:

    Import-Package: !com.unwanted.reference.*, *

A usually better way is to make the imports optional:

    Import-Package: com.unwanted.reference.*;resolution:=optional, *

Note the end at the Import-Package statement, that wildcard '*' is crucial for remaining imports, see [No Imports Show Up](?#noImports).

## No Imports Show Up
The imports that show up in your Import-Package manifest header are controlled by the bnd file's Import-Package instruction. In bnd, the list is a set of patterns that are sequentially applied to your imports as calculated by bnd from the classes, resources, and headers in the JAR.

The default Import-Package bnd instruction is:

    Import-Package: *

This imports all referred packages. The most common reasons imports do not appear in the manifest is that the default is overridden and the overrider forgot to add the wildcard '*' at the end. For example, the following is wrong:

    Import-Package: com.example; version=1.2

This will create an import for com.example but it ignores all other imports.

Another reason is the exclude operator ('!') that will remove imports. If this is too wild, then no imports are left to insert in the manifest. So the following leads to no imports for any package starting with com.example.

    Import-Package: !com.example.*, *

Last but not least, look at the `[USEDBY]` section of the JAR print out, make sure there are actually references.

## Why do I have imports without version ranges?

With `-pedantic:true` bnd creates a warning like

> Imports that lack version ranges due to not being found in any bundle on the -buildpath: `com.example.foo.bar` ...

These could stem from transitive dependencies of the jars on your buildpath.
There are multiple reasons for that, for example they could stem from transitive dependencies:
- of non-OSGi jars which are included via [-includeresource](/instructions/includeresource.html)
- of OSGi bundles on your classpath, if the import version ranges for those bundles are not specified in the Bundle. E.g. if the bundle imports the dependency via `Require-Bundle` it won't have the import range, or if it uses `Import-Package` with no import range.



## Why No Automatic Bundle-Activator <a name="automaticActivator"/>
Many people are surprised that bnd does not automatically calculate the Bundle-Activator. Basically, there are the following issues:

* Not all bundles have a bundle activator
* Detecting an activator in the code does not always mean you want one
* Detecting means you can find more than one

That said, it is possible to automate the Bundle-Activator:

    Bundle-Activator: \
       ${classes;IMPLEMENTS;org.osgi.framework.BundleActivator}

However, if there are multiple Bundle-Activators you will get an error.

## How to assign an unbind method to a @Reference? <a name="unbindMethod"/>
`@Reference` automatically sets the bind method but how is the unbind method set? Simple, you use a method with a similar name:

<table style="width:100%">
  <tr>
    <th>bind</th>
    <th>unbind</th>
  </tr>
  <tr>
    <td>setX</td>
    <td>unsetX</td>
  </tr>
  <tr>
    <td>addX</td>
    <td>removeX</td>
  </tr>
</table>

For example:

    @Reference
    protected void setFoo(LogService l) { ... }
    protected void unsetFoo(LogService l) { ... }

If you want to override this, use

    @Reference(unbind="IRefuseToCallMyMethodUnFoo");
    protected void foo(LogService l) {}
    protected void IRefuseToCallMyMethodUnFoo(LogService l) {}

Unfortunately Java has no method references so it is not type safe.A non existent `@UnReference` annotation is not very useful because that still requires linking it up symbolically to the associated `@Reference`.

## packageinfo or package-info.java? <a name="packageinfo"/>
I'm just a little bit confused about the bnd approach with the file naming "packageinfo". The [JLS](https://docs.oracle.com/javase/specs/jls/se8/html/jls-7.html) already defines "package-info.java" for package relevant infos. Wouldn't it be simplier (less complex) to have only one file for package definitions? So, the bnd tool could manage the package version in "package-info.java", too.

You can use either file. The reason there are two options is that one constituency thinks annotations are the only solution and the other is running pre Java 5 ... Basically if I would have to choose it would be packageinfo because that works anywhere but I expect that you probably would not like that :-) 

## Why are superclass not inspected for Component annotations? <a name="supercomps"/>
Annotations are not inherited from the component's super classes by default. The problem is that super classes from imported packages may be different at runtime than they were at build time. So it is always best to declare your annotations on the actual component class. Alternatively you can use the instruction `-dsannotations-options: inherit`. Then bnd will use DS annotations found in the class hierarchy of the component class. This will not work for the `@Component` annotation itself; it will not be inherited from super classes causing a subclass to suddenly be a component. 

## Why does bnd require a public no-arg constructor for my DS component? <a name="componentConstructor"/>
Starting with bnd 7.3.0, bnd enforces the DS specification requirement that component classes must have either a public no-argument constructor or a public constructor annotated with `@Activate` for constructor injection.

If you see this error:
```
The DS component class {className} must declare a public no-arg constructor, or a public constructor annotated with @Activate.
```

You need to either add a public no-arg constructor, use `@Activate` on your constructor, ensure your class is public, or make inner classes static.

See [Component Class Requirements](/chapters/200-components.html#component-class-requirements) for detailed explanations and code examples. 

## Can't find the source of the version on an Export-Package? <a name="exportversions"/>
If no explicit export version is specified in the bnd file then bnd will look in the following places.

* packageinfo file in the package directory (recommended)
* package-info.java, bnd's Version annotation
* Manifest of the exporting JAR
* The bundle version

The use of the bundle version is a rather bad idea, packages should be versioned independently. It is possible
to not use the bundle version for a package with:

    -nodefaultversion true


## Should I use the Bundle-ClassPath? <a name="bundleclasspath"/>
No. It creates unnecessary complexity, it is slower, and it is not necessary. It will also not be compatible with techniques like [PojoSR](https://code.google.com/archive/p/pojosr/), something that the OSGi is looking into standardizing.

## What should I use instead of the Bundle-ClassPath? <a name="bundleclasspath2"/>
Just use Private-Package and Export-Package, know what goes into your JAR. If you really need to wrap one or more JARs, use the Include-Resource instruction, it has an option to unroll a JAR resource (see [@ option](/instructions/includeresource.html#rolling). This will copy all its contents in the target JAR. The -exportcontents can then be used to export selected packages. Even better is of course to know 

## Sharing CNF Folder and BNDTools Projects <a name="workspaceSharing"/>
The [Best Practices section](/chapters/140-best-practices.html) provides some good tips about how you setup workspaces that share some information. 

-----

If an entry is wrong, send a [mail](mailto:bnd@aQute.biz) with the JAR that has the problem. Preferably as small as possible.

