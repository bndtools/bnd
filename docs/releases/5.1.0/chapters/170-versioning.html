<!DOCTYPE html>
<html lang="en" ng-app="jpm">

	<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="/releases/5.1.0/css/style.css" rel="stylesheet" />
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="/js/releases.js"></script>
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Versioning</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Versioning" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Versioning is probably the most painful part of developing real software. Where toys and prototypes can be developed ignoring evolution, real software requires a migration path to an unknown future." />
<meta property="og:description" content="Versioning is probably the most painful part of developing real software. Where toys and prototypes can be developed ignoring evolution, real software requires a migration path to an unknown future." />
<script type="application/ld+json">
{"url":"/releases/5.1.0/chapters/170-versioning.html","headline":"Versioning","description":"Versioning is probably the most painful part of developing real software. Where toys and prototypes can be developed ignoring evolution, real software requires a migration path to an unknown future.","@type":"WebPage","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


	

	

	

	

	

	

	

	

	

	
		<style>
			 body {
				counter-reset: h1 10;
			}
		</style>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

</head>


<body>

	
<ul class="container12 menu-bar">
	<li span=11><a class=menu-link href="/releases/5.1.0/"><img
			class=menu-logo src="/releases/5.1.0/img/bnd-80x40-white.png"></a>
			<a href="/releases/5.1.0/chapters/110-introduction.html">Intro
			</a><a href="/releases/5.1.0/chapters/800-headers.html">Headers
			</a><a href="/releases/5.1.0/chapters/825-instructions-ref.html">Instructions
			</a><a href="/releases/5.1.0/chapters/855-macros-ref.html">Macros
			</a><a href="/releases/5.1.0/chapters/400-commands.html">Commands
			</a><div class="releases"><button class="dropbtn">5.1.0</button><div class="dropdown-content"></div></div>
	<li class=menu-link span=1>
			<a href="https://github.com/bndtools/bnd" target="_"><img
	style="position:absolute;top:0;right:0;margin:0;padding:0;z-index:100"
	src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67"
	alt="Fork me on GitHub"
	data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
</ul>


					

	<ul class=container12>
		<li span=3>
			<div>
			<ul class="side-nav">
	
		
			<li><a href="/releases/5.1.0/chapters/110-introduction.html">Introduction</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/120-install.html">How to install bnd</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/123-tour-workspace.html">Guided Tour</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/125-tour-features.html">Guided Tour Workspace & Projects</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/130-concepts.html">Concepts</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/140-best-practices.html">Best practices</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/150-build.html">Build</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/155-project-setup.html">Project Setup</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/160-jars.html">Generating JARs</a>
	  	
  	
		
			<li class=selected>Versioning
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/180-baselining.html">Baselining</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/200-components.html">Service Components</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/210-metatype.html">Metatype</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/220-contracts.html">Contracts</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/230-manifest-annotations.html">Bundle Annotations</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/235-accessor-properties.html">Accessor Properties</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/240-spi-annotations.html">SPI Annotations</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/250-resolving.html">Resolving Dependencies</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/300-launching.html">Launching</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/305-startlevels.html">Startlevels</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/310-testing.html">Testing</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/315-launchpad-testing.html">Testing with Launchpad</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/320-packaging.html">Packaging Applications</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/330-jpms.html">JPMS Libraries</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/390-wrapping.html">Wrapping Libraries to OSGi Bundles</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/395-generating-documentation.html">Generating Documentation</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/400-commands.html">Commands</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/600-developer.html">For Developers</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/650-windows.html">Tips for Windows users</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/700-tools.html">Tools bound to bnd</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/800-headers.html">Headers</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/820-instructions.html">Instruction Reference</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/825-instructions-ref.html">Instruction Index</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/850-macros.html">Macro Reference</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/855-macros-ref.html">Macro Index</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/870-plugins.html">Plugins</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/875-external-plugins.html">External Plugins</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/880-settings.html">Settings</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/900-errors.html">Errors</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/910-warnings.html">Warnings</a>
	  	
  	
		
			<li><a href="/releases/5.1.0/chapters/920-faq.html">Frequently Asked Questions</a>
	  	
  	
</ul>

			</div>
			
		<li span=9>
			<div class=notes-margin>
				<h1> Versioning</h1>
				<p>Versioning is probably the most painful part of developing real software. Where toys and prototypes can be developed ignoring evolution, real software requires a migration path to an unknown future.</p>

<p>The OSGi has defined a versioning policy that is described in the <a href="https://www.osgi.org/wp-content/uploads/Semantic-Versioning-20190110.pdf">Semantic Versioning whitepaper</a>. bnd fully supports this model and provides many shortcuts. The goal of bnd is remove any manual work from versioning bundles as well as packages.</p>

<p>The key concept to version in OSGi is the ‘‘package’’. Bundles are an ‘‘aggregate’’ and therefore must move as fast as the fastest moving exported packages they contain. For example, if a bundle contains two exported packages <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar</code> and <code class="highlighter-rouge">foo</code> is not changed but <code class="highlighter-rouge">bar</code> has a major change, then the bundle version needs to also have a major change. This requires an unnecessary update for a bundle that only depended on <code class="highlighter-rouge">foo</code>. Aggregating dependencies increases the fan out of the transitive dependencies. The result is that systems can only evolve when everything is updated simultaneously. The result is that the system as a whole becomes brittle.</p>

<p>In contrast, versioning the packages and using Import-Package, bundles can be refactored and versioned independently.</p>

<h2 id="best-practices">Best Practices</h2>

<ul>
  <li>Version on packages, not on bundles</li>
  <li>Create a packageinfo file with “version 1.0” in each package directory and maintain it meticuously for each change to the package. Any change that breaks consumers, increment major. Changes that break providers (if any), increment minor. Other changes micro. bnd will then properly version this package when exported</li>
  <li>If you provide an API (as defined in te Semantic Versioning whitepaper) export the API package even if it is not in your project and put the <code class="highlighter-rouge">provide:=true</code> directive on the package export, e.g. <code class="highlighter-rouge">Export-Package: org.osgi.service.event; provide:=true</code>.</li>
  <li>Every time when you release a bundle to the external world, bump the minor part of the bundle  version. For internal development releases, bump the micro part of the bundle version.</li>
</ul>

<h2 id="versions-in-osgi">Versions in OSGi</h2>
<p>A version in OSGi has 4 parts:</p>

<p>major        1
  minor        1.1
  micro        1.1.1
  qualifier    1.1.1.qualifier</p>

<p>To survive versioning, one must have a ‘‘version policy’’. A version policy puts semantics on the version numbers. The ‘‘recommended’’ policy in OSGi is changing the part when there is:</p>

<p>major        a breaking change
  minor        a backward compatible changes
  micro        a bug fix (no API change)
  qualifier    a new build</p>

<p>In OSGi, the decision was taken to have a single export version. The import statement allows a version range to be set. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Export-Package: com.acme.foo; version=1.0.2
Import-Package: com.acme.bar; version="[1,2)"
</code></pre></div></div>

<p>The semantic versioning white paper introduces two terms that are orthogonal to the imports and exports as well as implementing or delegating:</p>

<ul>
  <li>Provide an API - Provide the functionality defined in an API</li>
  <li>Consume an API - Consume the functionality defined in an API</li>
</ul>

<p>Provide and consume is orthogonal to implementing an interface and delegating. For example, the Configuration Admin service has the <code class="highlighter-rouge">ConfigurationAdmin</code> interface that is implemented by the Provider of an API but the <code class="highlighter-rouge">ConfigurationListener</code> interface is implemented by the Consumer of the API.</p>

<p>The reason for the providers and consumer terms is that version policies are different. A change in an API almost always affects the provider but with careful API design it is often possible to make a change backward compatible for consumers.</p>

<p>In bnd, whenever you have to provide an import range, you can use modifiers to create a range out of a single version:</p>

<ul>
  <li><code class="highlighter-rouge">@1.2.3</code> – Creates an import up to the next major version: <code class="highlighter-rouge">[1.2.3,2.0.0)</code>.</li>
  <li><code class="highlighter-rouge">1.2.3@</code> – Creates an import up to the next minor version: <code class="highlighter-rouge">[1.2.3,1.3.0)</code>.</li>
  <li><code class="highlighter-rouge">=1.2.3</code> – Creates a range that only accepts that version: <code class="highlighter-rouge">[1.2.3,1.2.3]</code>.</li>
</ul>

<h2 id="versioning-packages">Versioning Packages</h2>
<p>If you have a package that is containing implementation code that is supposed to be directly used by the consumers then this is a ‘‘library’’.
A library package is not an API that can be implemented by other bundles, it is the implementation. Then the versioning of library packages is relatively straightforward: Any change that breaks a consumer of that package must increment the major version number. For example, if the popular ASM library would add a method to the <code class="highlighter-rouge">MethodVisitor</code> class then it must increment the major version number of the <code class="highlighter-rouge">org.objectweb.asm</code> package because all existing consumers of this library would then be broken.</p>

<p>If however a package contains an API that is provided and consumed by others the situation is more complex. In such a case, the provider should export the API package and the consumers should import it.</p>

<p>bnd explicitly allows the inclusion of packages that come from other projects. It is just good practice to include an API package in your bundle if you are the provider of that API. However, this means that maintaining the version of the package in the manifest is ‘‘wrong’’, it would have to be maintained in several places, which is very error prone.</p>

<p>For this reason, bnd provides a way to store the version of the package together with the package itself. One with annotations and one without when annotations are not possible.</p>

<p>The @Version annotation is placed on the package. Since Java 5 it is possible to create a package-info.java file that can be used to annotate packages:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="p">-</span><span class="n">info</span><span class="p">.</span><span class="n">java</span><span class="p">:</span>
    <span class="p">@</span><span class="k">Version</span><span class="p">(</span><span class="s2">"1.2.0.${build}"</span><span class="p">)</span>
    <span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">example</span><span class="p">;</span>

    <span class="n">import</span> <span class="n">aQute</span><span class="p">.</span><span class="n">bnd</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="k">Version</span><span class="p">;</span>
</code></pre></div></div>

<p>A non-annotation based alternative is the <code class="highlighter-rouge">packageinfo</code> file. When bnd scans the Java archives it will look in each package for this packageinfo file. The format of this file is very simple:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>packageinfo:
    version 1.2.0.v${build}
</code></pre></div></div>

<p>In either case, the value for the version may contain macros.</p>

<p>If you now export the package (from any bundle that has the package on its class path), it will be properly versioned.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bnd.bnd:
    build = ${tstamp}
    Export-Package: com.example.*
</code></pre></div></div>

<p>The resulting manifest will look like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Manifest:
    Export-Package: com.example; version=1.2.0.v201010101010
</code></pre></div></div>

<p>If you export a a package from another bundle, bnd will also look in the manifest of that other bundle for a version.</p>

<p>Using packageinfo (or the @Version annotation) is highly recommended.</p>

<h2 id="when-package-version-differ">When Package Version Differ</h2>

<p>The package version for package p can come from the following places (in order of increasing priority):</p>

<ul>
  <li><code class="highlighter-rouge">p/packageinfo</code></li>
  <li><code class="highlighter-rouge">p/package-info.java</code> with an annotation</li>
  <li>Manifest of the source bundle</li>
  <li>Manifest of the bundle under construction, i.e. the bnd.bnd file</li>
</ul>

<p>The bnd warning means that bnd finds multiple definitions of the version for p and they are not the same. So I assume you set the version in the manifest of the bundle under construction and in one of those other places. The best is to remove the version from your bnd.bnd file. The by far absolute best way is to only set the version of the package in the package directory (either <code class="highlighter-rouge">packageinfo</code> or <code class="highlighter-rouge">package-info.java</code> with an annotation).</p>

<h2 id="import-version-policy">Import Version Policy</h2>
<p>If you import a package bnd will look at the exported version of that package. This version is not directly suitable for the import because it is usually too specific, it needs a policy to convert this export version to an import version.</p>

<p>An importer that provides the functionality of an API package is much closer tied to that package than a client. The whitepaper recommends binding to the major.minor part of the version for a provider. That is, any change in the minor part of the version breaks the compatibility. This makes sense, the provider of an API must implement the contract and is therefore not backward compatible for any change in the API. A consumer of the API only has to be bound to the major part because it is much more relaxed for the backward compatibility.</p>

<p>For example, a new method is added to an interface that is implemented by the provider of the API. Old clients have no visibility of this method because when they compiled it did not exist. However, the provider of the API must be modified to implement this method otherwise more modern clients would break.</p>

<p>This asymmetry creates the need for two version policies:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-provider-policy :    ${range;[==,=+)}
-consumer-policy :    ${range;[==,+)}
</code></pre></div></div>

<p>The given values are the defaults. The value of the version policy will be used calculate the import based on the exported package. The <code class="highlighter-rouge">${range}</code> macro provides a convenient shortcut to do this using a version mask.</p>

<p>For example, a bundle that implements the OSGi Event Admin service can use the following bnd file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bnd.bnd:
    Private-Package: com.example.impl.event
</code></pre></div></div>

<p>The resulting manifest would look like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Manifest:
    Import-Package:  org.osgi.service.event; version="[1.1,2)", ...
    ...
</code></pre></div></div>

<p>How does bnd know if a bundle is a provider or a consumer of a specific package? Well, the default is the consumer policy but this can be overridden with the <code class="highlighter-rouge">provide:=true</code> directive that works on the <code class="highlighter-rouge">Import-Package</code> clauses as well as on the <code class="highlighter-rouge">Export-Package</code> clauses.</p>

<p>The <code class="highlighter-rouge">provide:</code> directive indicates to bnd that the given package contains API that is provided by this bundle. The (strongly) recommended way is to put the <code class="highlighter-rouge">provide:=true</code> directive on the <code class="highlighter-rouge">Export-Package</code> header, even if the package comes from another bundle. This way the bundle contains a copy of the package that is by default imported with the proper provider policy range.</p>

<p>For example, an implementation of the OSGi Event Admin specification could use the following bnd file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bnd.bnd:
    Export-Package:  org.osgi.service.event; provide:=true
    Private-Package: com.example.impl.event
</code></pre></div></div>

<p>The resulting manifest would look like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Manifest:
    Export-Package:  org.osgi.service.event; version=1.1
    Import-Package:  org.osgi.service.event; version="[1.1,1.2)", ...
    ...
</code></pre></div></div>

<p>If for some reason it is not desirable to export the API package in the implementation bundle, then the <code class="highlighter-rouge">provide:</code> directive can also be applied on the <code class="highlighter-rouge">Import-Package</code> header:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bnd.bnd
    Import-Package: org.osgi.service.event; provide:=true, *
    Private-Package: com.example.impl.event
</code></pre></div></div>

<p>The resulting manifest would look like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Manifest:
    Import-Package:  org.osgi.service.event; version="[1.1,1.2)", ...
    ...
</code></pre></div></div>

<h2 id="substitution">Substitution</h2>
<p>A key aspect of OSGi is that a package can be both imported and exported. The reason is that this feature allows a framework more leeway during resolving without creating multiple unconnected class spaces.</p>

<p>After the bundle has been created and analyzed bnd will see if an exported package is eligible for import. An export is automatically imported when the following are true:</p>

<ul>
  <li>There exists at least one reference to the exported package from a private package</li>
  <li>The exported package has no references to any private packages</li>
  <li>The exported package does not have a <code class="highlighter-rouge">-noimport:</code> directive.</li>
</ul>

<p>If a package is imported it will use the version as defined by the version policy.</p>

<h2 id="versioning-bundles">Versioning Bundles</h2>
<p>Versioning bundles usually requires bumping the version every time it is placed in a repository. When package versioning is used, the bundle version is only important for tracking an artifact.</p>

<h2 id="why-does-bnd-use-only-major-and-minor-version-component-in-import-package-headers">Why does bnd use only major and minor version component in import-package headers?</h2>

<p>The micro is left out because it generates a lot of unnecessary releases, this is similar to the maven release process. If you connect everything 100%, you cannot move anything unless all its dependencies are moved at the same time. We actually tried in the OSGi build to use micro version changes for default methods in Java 8 but found that it just creates an enormous ripple through effect in the build. Not depending on the micro version is a lubricant that does not kill any bundle out there that depends on you.</p>

<p>This should not be a problem because a micro version is a deployment issue since the semantic versioning should be used for APIs and a micro change is not visible in the API.</p>

<p>That said, this is bnd so obviously you can override it. You can override the default version policy is:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-provider-policy = ${range;[==,=+)}
-consumer-policy = ${range;[==,+)}
</code></pre></div></div>

<p>Just set ‘===’ instead of ‘==’ for the floor version in your pom.xml in the <configuration> section and you should be ok.</configuration></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;configuration&gt;
	&lt;_provider-policy&gt;${range;[===,=+)}&lt;/_provider-policy&gt;
	&lt;_consumer-policy&gt;${range;[===,+)}&lt;/_consumer-policy&gt;
&lt;/configuration&gt;
</code></pre></div></div>


			</div>
	</ul>

	
<nav class=next-prev>
	<a href='/releases/5.1.0/chapters/160-jars.html'></a> <a href='/releases/5.1.0/chapters/180-baselining.html'></a>
</nav>
<footer class="container12" style="border-top: 1px solid black;padding:10px 0">
	<ul span=12 row>
		<li span=12>
			<ul>
				<li><a href="/releases/5.1.0/">GitHub</a>
			</ul>
	</ul>
</footer>

</body>
</html>
