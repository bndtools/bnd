package aQute.bnd.eclipse;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Formatter;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import aQute.bnd.build.Project;
import aQute.bnd.build.model.BndEditModel;
import aQute.bnd.build.model.clauses.ExportedPackage;
import aQute.bnd.header.Parameters;
import aQute.bnd.osgi.Constants;
import aQute.bnd.osgi.Instruction;
import aQute.bnd.osgi.Instructions;
import aQute.bnd.properties.Document;
import aQute.bnd.service.lifecycle.LifeCyclePlugin;
import aQute.bnd.version.Version;
import aQute.lib.io.IO;
import aQute.lib.strings.Strings;
import aQute.lib.tag.Tag;
import aQute.lib.utf8properties.UTF8Properties;
import aQute.libg.glob.Glob;

public class EclipseLifecyclePlugin extends LifeCyclePlugin {
	static XPathFactory	xpf								= XPathFactory.newInstance();

	static Pattern		PACKAGE_INFO_VERSION_MATCH_P	= Pattern
			.compile("@.*\\.Version\\s*(\\s*\\\"([^\"]+)\"\\s*)\\s*(;|\r?\n)");
	static Glob[]		IGNORE_PROJECT_BUILDCOMMAND		= {
			new Glob("org.eclipse.pde.*"), new Glob("org.eclipse.m2e.*")
	};

	static Glob[]		IGNORE_PROJECT_NATURE			= {
			new Glob("org.eclipse.pde.*"), new Glob("org.eclipse.m2e.*")
	};

	@Override
	public void created(Project project) throws Exception {

		File cp = project.getFile(".classpath");
		if (!cp.isFile()) {
			Tag cpTag = toClasspathTag(project, null);
			IO.store(cpTag.toString(), cp);
		}

		File projectFile = project.getFile(".project");
		if (!projectFile.isFile()) {
			Tag projectTag = toProjectTag(project, null);
			IO.store(projectTag.toString(), projectFile);
		}

		super.created(project);
	}

	static Tag toProjectTag(Project project, org.w3c.dom.Document original) throws Exception {
		XPath xp = xpf.newXPath();

		Tag projectTag = new Tag("projectDescription");
		new Tag(projectTag, "name", project.getName());
		new Tag(projectTag, "comment", "generated by bnd");
		Tag buildSpec = new Tag(projectTag, "buildSpec");

		List<String> originalBuildCommands = getNames(xp, original, "/projectDescription/buildSpec/buildCommand/name");
		addIfNotExist(originalBuildCommands, 0, "org.eclipse.jdt.core.javabuilder");
		addIfNotExist(originalBuildCommands, -1, "bndtools.core.bndbuilder");
		
		originalBuildCommands.removeIf(s -> Glob.in(IGNORE_PROJECT_BUILDCOMMAND, s));
		for ( String bc : originalBuildCommands) {
			Tag buildCommand = new Tag(buildSpec, "buildCommand");
			new Tag(buildCommand, "name", bc);
			
			// TODO arguments
		}


		List<String> originalNatures = getNames(xp, original, "/projectDescription/natures/nature");
		addIfNotExist(originalNatures, -1, "org.eclipse.jdt.core.javanature");
		addIfNotExist(originalNatures, -1, "bndtools.core.bndnature");
		originalNatures.removeIf(s -> Glob.in(IGNORE_PROJECT_NATURE, s));

		Tag natures = new Tag(projectTag, "natures");
		for (String nature : originalNatures) {
			new Tag(natures, "nature", nature);
		}


		Parameters extraNatures = new Parameters(project.getProperty("eclipse.natures"));
		for (String extraNature : extraNatures.keySet()) {
			new Tag(natures, "nature", extraNature);
		}

		return projectTag;
	}

	private static void addIfNotExist(List<String> list, int where, String value) {
		if (list.contains(value))
			return;

		if (where >= 0)
			list.add(where, value);
		else
			list.add(value);
	}

	private static List<String> getNames(XPath xp, org.w3c.dom.Document source, String expression) throws Exception {
		ArrayList<String> names = new ArrayList<>();

		if (source != null) {

			NodeList nodes = (NodeList) xp.evaluate(expression, source, XPathConstants.NODESET);
			for (int i = 0; i < nodes.getLength(); i++) {
				String name = nodes.item(i).getTextContent();
				if (name != null) {
					names.add(Strings.trim(name));
				}
			}
		}

		return names;

	}

	// <?xml version="1.0" encoding="UTF-8"?>
	// <classpath>
	// <classpathentry kind="src" output="bin" path="src"/>
	// <classpathentry kind="src" output="bin_test" path="test"/>
	// <classpathentry kind="con"
	// path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
	// <classpathentry kind="con" path="aQute.bnd.classpath.container"/>
	// <classpathentry kind="output" path="bin"/>
	// </classpath>

	public static String toClasspath(Project project, org.w3c.dom.Document original) throws Exception {
		return toClasspathTag(project, original).toString();
	}

	static Tag toClasspathTag(Project project, org.w3c.dom.Document original) throws Exception {

		String mainOutput = project.getProperty(Constants.DEFAULT_PROP_BIN_DIR);
		String testOutput = project.getProperty(Constants.DEFAULT_PROP_TESTBIN_DIR);

		List<String> mainSources = Strings.split(project.getProperty(Constants.DEFAULT_PROP_SRC_DIR));
		List<String> mainResources = Strings.split(project.getProperty(Constants.DEFAULT_PROP_RESOURCES_DIR));
		mainResources.removeAll(mainSources);

		List<String> testSources = Strings.split(project.getProperty(Constants.DEFAULT_PROP_TESTSRC_DIR));
		List<String> testResources = Strings.split(project.getProperty(Constants.DEFAULT_PROP_TESTRESOURCES_DIR));
		testResources.removeAll(testSources);


		Tag top = new Tag("classpath");
		Tag jre = new Tag(top, "classpathentry");
		String javaTarget = project.getProperty("java.target", "1.8");

		if (!javaTarget.matches("\\d+\\.\\d+")) {
			project.error("Invalid java.target property. Is %s bust match like 1.8. Assuming 1.8", javaTarget);
			javaTarget = "1.8";
		}

		jre.addAttribute("kind", "con");

		String vmtype;
		if (new Version(javaTarget).getMinor() <= 5)
			vmtype = "J2SE-" + javaTarget;
		else
			vmtype = "JavaSE-" + javaTarget;

		jre.addAttribute("path",
				"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/"
						+ vmtype);

		Tag bnd = new Tag(top, "classpathentry");
		bnd.addAttribute("kind", "con");
		bnd.addAttribute("path", "aQute.bnd.classpath.container");

		Tag b = new Tag(top, "classpathentry");
		b.addAttribute("kind", "output");
		b.addAttribute("path", project.getProperty(Constants.DEFAULT_PROP_BIN_DIR));

		doClassPathEntry(mainOutput, mainSources, top);
		doClassPathEntry(mainOutput, mainResources, top);
		doClassPathEntry(testOutput, testSources, top);
		doClassPathEntry(testOutput, testResources, top);

		if (original != null)
			copyAuxlilaryEntries(project, original, mainOutput, top);

		return top;
	}

	private static void copyAuxlilaryEntries(Project project, org.w3c.dom.Document original, String mainOutput, Tag top)
	        throws XPathExpressionException {
		XPath xp = xpf.newXPath();
		NodeList nodes = (NodeList) xp.evaluate("//classpathentry", original, XPathConstants.NODESET);
		Instructions languages = new Instructions(
		        project.getProperty("pde.additional.languages", "src/main/groovy, src/test/groovy"));

		for (int i = 0; i < nodes.getLength(); i++) {
			Node node = nodes.item(i);
			String path = node.getAttributes().getNamedItem("path").getTextContent();
			Instruction instruction = languages.matcher(path);
			if (instruction == null)
				continue;

			doClassPathEntry(mainOutput, Collections.singleton(path), top);
		}
	}

	private static void doClassPathEntry(String mainOutput, Collection<String> mainSources, Tag top) {
		for (String path : mainSources) {
			Tag s = new Tag(top, "classpathentry");
			s.addAttribute("kind", "src");
			s.addAttribute("path", path);
			s.addAttribute("output", mainOutput);
		}
	}

	public static void moveExportedVersionsToJavaInfo(Project project) throws Exception {
		String bnd = IO.collect(project.getPropertiesFile());
		Document document = new Document(bnd);
		BndEditModel model = new BndEditModel();
		model.loadFrom(document);
		List<ExportedPackage> exportedPackages = model.getExportedPackages();
		if (exportedPackages == null)
			return;

		boolean changes = false;

		nextPackage: for (ExportedPackage exportedPackage : exportedPackages) {
			String packageDir = exportedPackage.getName().replace('.', '/');
			String manifestVersion = exportedPackage.getVersionString();
			if (manifestVersion != null) {
				for (File sourceDirectory : project.getSourcePath()) {

					File packageInfo = IO.getFile(sourceDirectory, packageDir + "/package-info.java");

					if (packageInfo.isFile()) {
						changes = doExistingJavaInfoPackage(project, changes, exportedPackage, manifestVersion,
								packageInfo);
						continue nextPackage;
					} else if (packageInfo.getParentFile().isDirectory()) {
						doCreatePackageInfo(packageInfo, packageDir, manifestVersion);
						exportedPackage.setVersionString(null);
						changes = true;
					}
				}
			}
		}
		if (changes)
			model.setExportedPackages(exportedPackages);

		model.saveChangesTo(document);
		bnd = document.get();
		IO.store(bnd, project.getPropertiesFile());
		project.refresh();
	}

	private static boolean doExistingJavaInfoPackage(Project p, boolean changes, ExportedPackage exportedPackage,
			String manifestVersion, File packageInfo) throws IOException {
		String content = IO.collect(packageInfo);
		Matcher m = PACKAGE_INFO_VERSION_MATCH_P.matcher(content);
		boolean hasVersionAnnotation = m.matches();
		if (hasVersionAnnotation) {
			String fileVersion = m.group(1);
			boolean manifestAndAnnotationAreSameVersion = manifestVersion.equals(fileVersion);
			if (manifestAndAnnotationAreSameVersion) {
				exportedPackage.setVersionString(null);
				changes = true;
			} else {
				p.warning("Different package version in bnd file %s", packageInfo);
			}
		} else /* no annotation in file */ {
			content = content.replaceAll("($|\n|\r)\\s*package\\s+",
					"\n@org.osgi.annotation.versioning.Version(\"" + manifestVersion + "\")\npackage ");
			IO.store(content, packageInfo);
		}
		return changes;
	}

	private static void doCreatePackageInfo(File packageInfoFile, String packg, String versionString)
			throws IOException {
		try (Formatter f = new Formatter()) {
			f.format("@org.osgi.annotation.versioning.Version(\"%s\")\n", versionString);
			f.format("package %s;\n", packg.replace('/', '.'));
			IO.store(f.toString(), packageInfoFile);
		}
	}

	public static void updateSettingsJDT(Project p) throws IOException {
		UTF8Properties props = new UTF8Properties();
		File pf = p.getFile(".settings/org.eclipse.jdt.core.prefs");
		if (pf.isFile()) {
			try (InputStream in = new FileInputStream(pf)) {
				props.load(in);
			}
		} else
			pf.getParentFile().mkdirs();

		String javactarget = p.getProperty(Constants.JAVAC_TARGET, "1.8");
		String javacSource = p.getProperty(Constants.JAVAC_SOURCE, "1.8");

		props.setProperty("org.eclipse.jdt.core.compiler.codegen.targetPlatform", javactarget);
		props.setProperty("org.eclipse.jdt.core.compiler.codegen.source", javacSource);
		props.setProperty("org.eclipse.jdt.core.compiler.codegen.compliance", javacSource);
		props.setProperty("org.eclipse.jdt.core.compiler.source", javacSource);
		props.setProperty("org.eclipse.jdt.core.compiler.compliance", javacSource);
		props.setProperty("org.eclipse.jdt.core.compiler.codegen.methodParameters", "generate");

		props.store(pf);
	}

}
